# File: app/controllers/application_controller.rb
class ApplicationController < ActionController::API
end


# File: app/controllers/instruments_controller.rb
class InstrumentsController < ApplicationController
end


# File: app/controllers/mis_details_controller.rb
class MisDetailsController < ApplicationController
end


# File: app/controllers/options_controller.rb
class OptionsController < ApplicationController
  def suggest_strategies
    strategies = Option::SuggestStrategyService.call(
      index_symbol: params[:index_symbol],
      expiry_date: params[:expiry_date],
      params: params
    )
    render json: { strategies: strategies }
  rescue StandardError => e
    render json: { error: e.message }, status: :unprocessable_entity
  end
end


# File: app/controllers/orders_controller.rb


# File: app/controllers/webhooks/alerts_controller.rb
class Webhooks::AlertsController < ApplicationController
  def create
    pp params

    alert = Alert.new(alert_params)



    if valid_alert?(alert_params)
      # Create the alert with a pending status
      alert = Alert.create(alert_params)

      if alert.persisted?
        # Process the alert asynchronously
        AlertProcessor.call(alert)

        render json: { message: "Alert processed successfully", alert: alert }, status: :ok
      else
        render json: { error: "Failed to save alert", details: alert.errors.full_messages }, status: :unprocessable_entity
      end
    else
      render json: { error: "Invalid or delayed alert" }, status: :unprocessable_entity
    end
  end

  private

  def alert_params
    params.require(:alert).permit(
      :ticker, :instrument_type, :order_type, :current_position, :previous_position, :current_price,
      :high, :low, :volume, :time, :chart_interval, :stop_loss, :take_profit, :trailing_stop_loss,
      :strategy_name, :strategy_id, :action, :strategy_type
    )
  end

  # Validate alert timestamp to ensure it's not delayed beyond 60 seconds
  def valid_alert?(alert)
    Time.zone.now - Time.parse(alert[:time]) < 60 || true
  rescue ArgumentError
    false
  end

  def parse_payload
    payload = JSON.parse(request.body.read)
    AlertValidator.new(payload)
  end
end


# File: app/jobs/application_job.rb
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end


# File: app/jobs/trailing_stop_loss_job.rb
class TrailingStopLossJob < ApplicationJob
  queue_as :default

  def perform
    Position.where(status: "active").find_each do |position|
      latest_price = fetch_latest_price(position.ticker)
      next unless latest_price

      new_stop_loss = calculate_new_stop_loss(position, latest_price)

      update_stop_loss_order(position, new_stop_loss) if new_stop_loss != position.stop_loss_price
    end
  rescue StandardError => e
    Rails.logger.error("TrailingStopLossJob failed: #{e.message}")
  end

  private

  def fetch_latest_price(ticker)
    # Fetch from WebSocket or other market feed
  end

  def calculate_new_stop_loss(position, latest_price)
    return position.stop_loss_price if latest_price <= position.entry_price

    delta = position.trailing_stop_loss
    position.action == "BUY" ? latest_price - delta : latest_price + delta
  end

  def update_stop_loss_order(position, new_stop_loss)
    Dhanhq::API::Orders.modify(position.dhan_order_id, triggerPrice: new_stop_loss)
    position.update(stop_loss_price: new_stop_loss)
  end
end


# File: app/jobs/update_strategy_examples_job.rb
class UpdateStrategyExamplesJob < ApplicationJob
  queue_as :default

  def perform(option_chain, params)
    Option::StrategyExampleUpdater.update_examples(option_chain, params)
  end
end


# File: app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end


# File: app/models/alert.rb
class Alert < ApplicationRecord
  validates :ticker, :instrument_type, :order_type, :current_price, :time, :strategy_name, :strategy_id, presence: true
  validates :instrument_type, inclusion: { in: %w[stock index crypto forex] }
  validates :order_type, inclusion: { in: %w[market limit stop] }
  validates :current_price, :high, :low, :volume, :stop_loss, :take_profit, :trailing_stop_loss, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true

  enum :status, { pending: "pending", processed: "processed", failed: "failed" }
end


# File: app/models/application_record.rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end


# File: app/models/instrument.rb
class Instrument < ApplicationRecord
  # Define the enum for instrument_type with string mapping
  enum :instrument_type, {
    "FUTCUR" => "FUTCUR",
    "OPTCUR" => "OPTCUR",
    "OPTIDX" => "OPTIDX",
    "FUTIDX" => "FUTIDX",
    "OPTSTK" => "OPTSTK",
    "FUTSTK" => "FUTSTK",
    "ES" => "ES",
    "Other" => "Other",
    "ETF" => "ETF",
    "MF" => "MF",
    "InvITU" => "InvITU",
    "REIT" => "REIT",
    "EQ" => "EQ",
    "PS" => "PS",
    "CB" => "CB",
    "DBT" => "DBT",
    "DEB" => "DEB",
    "TB" => "TB",
    "GB" => "GB",
    "PN" => "PN",
    "PTC" => "PTC",
    "INDEX" => "INDEX",
    "IDX" => "IDX",
    "FUTCOM" => "FUTCOM",
    "OPTFUT" => "OPTFUT",
    "CUR OP" => "CUR OP",
    "FUT" => "FUT",
    "OP" => "OP"
  }, prefix: :instrument_type

  # Define the enum for segment with string mapping
  enum :segment, {
    "C" => "C",  # Currency
    "D" => "D",  # Derivative
    "E" => "E",  # Equity
    "I" => "I",  # Index
    "M" => "M"   # Commodity
  }, prefix: :segment

  # Define expiry_flag without prefix
  enum :expiry_flag, {
    "1" => "1",  # Immediate
    "H" => "H",  # Half Yearly
    "M" => "M",  # Monthly
    "Q" => "Q",  # Quarterly
    "W" => "W"   # Weekly
  }, prefix: true

  has_one :mis_detail, dependent: :destroy

  # Validation
  validates :instrument_type, inclusion: { in: Instrument.instrument_types.keys }
  validates :segment, inclusion: { in: Instrument.segments.keys }

  # Scopes
  scope :equities, -> { where(instrument_type: "EQ") }
  scope :indices, -> { where(instrument_type: "INDEX") }
  scope :currencies, -> { where(segment: "C") }
  scope :expiring_soon, -> { where(expiry_flag: "1") }

  # Instance Methods
  def display_name
    "#{name} (#{instrument_type})"
  end

  def full_segment_name
    case segment
    when "C" then "Currency"
    when "D" then "Derivative"
    when "E" then "Equity"
    when "I" then "Index"
    when "M" then "Commodity"
    else "Unknown"
    end
  end

  def ltp
    # Dynamically derive the exchange segment
    exchange_segment = self.exchange_segment
    return nil if exchange_segment == "UNKNOWN"

    # Call the API using the derived segment and security ID
    response = Dhanhq::API::MarketFeed.ltp({ exchange_segment => [ security_id.to_i ] })

    # Check the response status and return the LTP or log an error
    if response["status"] == "success"
      response.dig("data", exchange_segment, security_id.to_s, "last_price")
    else
      Rails.logger.error("Failed to fetch LTP for Instrument #{id}: #{response[:remarks]}")
      nil
    end
  rescue StandardError => e
    Rails.logger.error("Exception in fetching LTP for Instrument #{id}: #{e.message}")
    nil
  end

  def ohlc
    # Dynamically derive the exchange segment
    exchange_segment = self.exchange_segment
    return nil if exchange_segment == "UNKNOWN"

    # Call the API using the derived segment and security ID
    response = Dhanhq::API::MarketFeed.ohlc({ exchange_segment => [ security_id.to_i ] })

    # Check the response status and return the OHLC or log an error
    if response["status"] == "success"
      response.dig("data", exchange_segment, security_id.to_s)
    else
      Rails.logger.error("Failed to fetch OHLC for Instrument #{id}: #{response[:remarks]}")
      nil
    end
  rescue StandardError => e
    Rails.logger.error("Exception in fetching OHLC for Instrument #{id}: #{e.message}")
    nil
  end

  def depth
    # Dynamically derive the exchange segment
    exchange_segment = self.exchange_segment
    return nil if exchange_segment == "UNKNOWN"

    # Call the API using the derived segment and security ID
    response = Dhanhq::API::MarketFeed.quote({ exchange_segment => [ security_id.to_i ] })

    # Check the response status and return the depth or log an error
    if response["status"] == "success"
      response.dig("data", exchange_segment, security_id.to_s)
    else
      Rails.logger.error("Failed to fetch Depth for Instrument #{id}: #{response[:remarks]}")
      nil
    end
  rescue StandardError => e
    Rails.logger.error("Exception in fetching Depth for Instrument #{id}: #{e.message}")
    nil
  end

  def fetch_option_chain(expiry)
    Dhanhq::API::Option.chain(
      UnderlyingScrip: security_id,
      UnderlyingSeg: segment,
      Expiry: expiry
    )
  end

  # Derive the exchange segment string for the API
  def exchange_segment
    exchange_segment_mapping.fetch([ exch_id, segment ], "UNKNOWN")
  end

  private

  # Mapping table for exchange segments
  def exchange_segment_mapping
    {
      [ "NSE", "E" ] => "NSE_EQ",
      [ "NSE", "D" ] => "NSE_FNO",
      [ "NSE", "C" ] => "NSE_CURRENCY",
      [ "BSE", "E" ] => "BSE_EQ",
      [ "BSE", "D" ] => "BSE_FNO",
      [ "BSE", "C" ] => "BSE_CURRENCY",
      [ "MCX", "M" ] => "MCX_COMM",
      [ "NSE", "I" ] => "IDX_I"
    }
  end
end


# File: app/models/mis_detail.rb
class MisDetail < ApplicationRecord
  belongs_to :instrument

  validates :mis_leverage, presence: true
end


# File: app/models/order.rb
class Order < ApplicationRecord
end


# File: app/models/position.rb
class Position < ApplicationRecord
end


# File: app/models/strategy.rb
class Strategy < ApplicationRecord
  validates :name, presence: true, uniqueness: true
end


# File: app/services/alert_processor.rb
class AlertProcessor < ApplicationService
  def initialize(alert)
    @alert = alert
  end

  def call
    handle_open_position

    strategy = select_strategy
    raise "Strategy not found for instrument type: #{@alert[:instrument_type]}" unless strategy

    order_response = strategy.execute

    setup_trailing_stop_loss(order_response) if order_response&.dig("orderId")

    @alert.update(status: "processed")
  rescue StandardError => e
    @alert.update(status: "failed", error_message: e.message)
    Rails.logger.error("Failed to process alert #{@alert.id}: #{e.message}")
  end

  private

  attr_reader :alert

  # Handle open positions and close them if profitable
  def handle_open_position
    position = fetch_open_position

    return unless position && position_profitable?(position)

    close_position(position)
  end

  def fetch_open_position
    positions = Dhanhq::API::Portfolio.positions
    positions.find { |pos| pos["tradingSymbol"] == alert[:ticker] && pos["positionType"] != "CLOSED" }
  end

  def position_profitable?(position)
    position["unrealizedProfit"].to_f > 20.00
  end

  def close_position(position)
    order_data = {
      transactionType: position["positionType"] == "LONG" ? "SELL" : "BUY",
      exchangeSegment: position["exchangeSegment"],
      productType: position["productType"],
      orderType: "MARKET",
      validity: "DAY",
      securityId: position["securityId"],
      quantity: position["netQty"]
    }

    Dhanhq::API::Orders.place(order_data)
  rescue StandardError => e
    raise "Failed to close position for #{position['tradingSymbol']}: #{e.message}"
  end

  def select_strategy
    strategy_suffix = alert[:strategy_id]&.split("_")&.last

    case alert[:instrument_type].downcase
    when "stock"
      case strategy_suffix
      when "intraday" then Orders::Strategies::IntradayStockStrategy.new(alert)
      when "swing"    then Orders::Strategies::SwingStockStrategy.new(alert)
      when "long_term" then Orders::Strategies::StockOrderStrategy.new(alert)
      else
        raise "Unsupported stock strategy: #{strategy_suffix}"
      end
    when "index", "option"
      case strategy_suffix
      when "intraday" then Orders::Strategies::IntradayOptionsStrategy.new(alert)
      when "swing"    then Orders::Strategies::SwingOptionsStrategy.new(alert)
      when "long_term" then Orders::Strategies::LongTermOptionsStrategy.new(alert)
      else
        Orders::Strategies::OptionsStrategy.new(alert) # Default to generic options strategy
      end
    else
      raise "Unsupported instrument type: #{alert[:instrument_type]}"
    end
  end

  def setup_trailing_stop_loss(order_response)
    order_details = fetch_order_details(order_response["orderId"])

    return unless order_details

    TrailingStopLossService.new(
      order_id: order_details["orderId"],
      security_id: order_details["securityId"],
      transaction_type: alert[:action],
      trailing_stop_loss_percentage: alert[:trailing_stop_loss]
    ).call
  end

  def fetch_order_details(order_id)
    response = Dhanhq::API::Orders.find(order_id)
    raise "Failed to fetch order details for order ID #{order_id}" unless response

    response
  end
end


# File: app/services/algo_trading/order_manager.rb
# app/services/algo_trading/order_manager.rb
module AlgoTrading
  class OrderManager
    def initialize
      @market_feed_handler = WebsocketHandlers::MarketFeedHandler.new
      @order_update_handler = WebsocketHandlers::OrderUpdateHandler.new
    end

    def start
      Thread.new { @market_feed_handler.listen }
      Thread.new { @order_update_handler.listen }
    end

    def place_order(alert, market_data)
      order_params = {
        transactionType: alert[:action].upcase,
        orderType: "LIMIT",
        price: calculate_limit_price(market_data),
        securityId: alert[:security_id],
        quantity: calculate_quantity(alert[:current_price]),
        productType: "INTRA"
      }
      Dhanhq::API::Orders.place(order_params)
    end

    def calculate_limit_price(market_data)
      # Use precision of 0.05 for limit orders
      (market_data["last_price"] * 0.95).round(2)
    end

    def calculate_quantity(price)
      available_funds = Dhanhq::API::Funds.balance["availabelBalance"].to_f
      (available_funds * 0.3 / price).floor
    end
  end
end


# File: app/services/algo_trading/stop_loss_manager.rb
# app/services/algo_trading/stop_loss_manager.rb
module AlgoTrading
  class StopLossManager
    def initialize
      @order_update_handler = WebsocketHandlers::OrderUpdateHandler.new
    end

    def adjust_stop_loss(order, market_data)
      new_stop_loss = calculate_stop_loss(market_data["last_price"])
      Dhanhq::API::Orders.modify(order_id: order[:id], stop_loss_price: new_stop_loss)
    end

    def calculate_stop_loss(current_price)
      (current_price * 0.98).round(2) # 2% below current price
    end
  end
end


# File: app/services/application_service.rb
class ApplicationService
  def self.call(*args, &block)
    new(*args, &block).call
  end

  # Optional: Override this to define a custom error handler in subclasses
  def handle_error(error)
    raise error
  end
end


# File: app/services/instrument_sync_service.rb
require "csv"
require "open-uri"

class InstrumentSyncService
  DETAILED_CSV_URL = "https://images.dhan.co/api-data/api-scrip-master-detailed.csv"

  def self.sync_instruments
    csv_file = download_csv

    CSV.foreach(csv_file.path, headers: true) do |row|
      expiry_date = parse_date(row["SM_EXPIRY_DATE"])
      next if expiry_date && expiry_date < Date.today

      # # Check if the instrument already exists
      # existing_instrument = Instrument.find_by(security_id: row["SECURITY_ID"])
      # next if existing_instrument # Skip if the instrument is already present

      # Create or update the instrument
      Instrument.find_or_initialize_by(security_id: row["SECURITY_ID"]).tap do |instrument|
        instrument.exch_id = row["EXCH_ID"]
        instrument.segment = row["SEGMENT"]
        instrument.isin = row["ISIN"]
        instrument.instrument = row["INSTRUMENT"]
        instrument.underlying_symbol = row["UNDERLYING_SYMBOL"]
        instrument.symbol_name = row["SYMBOL_NAME"]
        instrument.display_name = row["DISPLAY_NAME"]
        instrument.instrument_type = row["INSTRUMENT_TYPE"]
        instrument.lot_size = row["LOT_SIZE"].to_i
        instrument.sm_expiry_date = expiry_date
        instrument.strike_price = row["STRIKE_PRICE"].to_f
        instrument.option_type = row["OPTION_TYPE"]
        instrument.tick_size = row["TICK_SIZE"].to_f
        instrument.expiry_flag = row["EXPIRY_FLAG"] != "NA" ? row["EXPIRY_FLAG"] : nil
        instrument.asm_gsm_flag = row["ASM_GSM_FLAG"]
        instrument.buy_co_min_margin_per = row["BUY_CO_MIN_MARGIN_PER"].to_f
        instrument.sell_co_min_margin_per = row["SELL_CO_MIN_MARGIN_PER"].to_f
        instrument.buy_bo_min_margin_per = row["BUY_BO_MIN_MARGIN_PER"].to_f
        instrument.sell_bo_min_margin_per = row["SELL_BO_MIN_MARGIN_PER"].to_f
        instrument.mtf_leverage = row["MTF_LEVERAGE"].to_f

        instrument.save!
      end
    end
  ensure
    csv_file.close
    csv_file.unlink
  end

  private

  def self.download_csv
    tmp_file = Tempfile.new("api-scrip-master-detailed.csv")
    URI.open(DETAILED_CSV_URL) do |data|
      tmp_file.write(data.read)
    end
    tmp_file.rewind
    tmp_file
  end

  def self.parse_date(date_string)
    Date.parse(date_string) rescue nil
  end
end


# File: app/services/market_feed/adjustment_strategy.rb
module MarketFeed
  class AdjustmentStrategy
    def initialize(data)
      @data = data
    end

    def adjust
      # Example: Place limit orders or adjust stop-losses
      Rails.logger.info "Adjusting strategy for #{@data['SecurityId']}"
    end
  end
end


# File: app/services/market_feed/data_processor.rb
module MarketFeed
  class DataProcessor
    def initialize(data)
      @data = data
    end

    def process
      # Example logic: Parse and handle the market feed
      update_strategy if significant_movement?
    end

    private

    def significant_movement?
      # Implement logic to detect significant price changes
      @data["priceChange"] > 1.0
    end

    def update_strategy
      MarketFeed::AdjustmentStrategy.new(@data).adjust
    end
  end
end


# File: app/services/market_feed/handlers/full_packet_handler.rb
module MarketFeed
  module Handlers
    class FullPacketHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1("F"),
          last_traded_quantity: @io.read(2).unpack1("n"),
          last_traded_time: @io.read(4).unpack1("N"),
          average_trade_price: @io.read(4).unpack1("F"),
          volume: @io.read(4).unpack1("N"),
          open_interest: @io.read(4).unpack1("N"),
          day_high: @io.read(4).unpack1("F"),
          day_low: @io.read(4).unpack1("F"),
          market_depth: parse_market_depth
        }
      end

      private

      def parse_market_depth
        Array.new(5) do
          {
            bid_quantity: @io.read(4).unpack1("N"),
            ask_quantity: @io.read(4).unpack1("N"),
            bid_orders: @io.read(2).unpack1("n"),
            ask_orders: @io.read(2).unpack1("n"),
            bid_price: @io.read(4).unpack1("F"),
            ask_price: @io.read(4).unpack1("F")
          }
        end
      end
    end
  end
end


# File: app/services/market_feed/handlers/quote_handler.rb
module MarketFeed
  module Handlers
    class QuoteHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1("F"),
          last_traded_quantity: @io.read(2).unpack1("n"),
          last_traded_time: @io.read(4).unpack1("N"),
          average_trade_price: @io.read(4).unpack1("F"),
          volume: @io.read(4).unpack1("N"),
          total_sell_quantity: @io.read(4).unpack1("N"),
          total_buy_quantity: @io.read(4).unpack1("N"),
          day_open: @io.read(4).unpack1("F"),
          day_high: @io.read(4).unpack1("F"),
          day_low: @io.read(4).unpack1("F")
        }
      end
    end
  end
end


# File: app/services/market_feed/handlers/ticker_handler.rb
module MarketFeed
  module Handlers
    class TickerHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1("F"), # Float
          last_traded_time: @io.read(4).unpack1("N")   # Unsigned 32-bit
        }
      end
    end
  end
end


# File: app/services/market_feed/packet_parser.rb
module MarketFeed
  class PacketParser
    def self.parse(binary_data)
      # Convert binary data into a readable format
      io = StringIO.new(binary_data)

      # Parse the Response Header
      response_code = io.read(1).unpack1("C") # Unsigned char
      message_length = io.read(2).unpack1("n") # Unsigned 16-bit (big-endian)
      exchange_segment = io.read(1).unpack1("C") # Unsigned char
      security_id = io.read(4).unpack1("N") # Unsigned 32-bit (big-endian)

      # Fetch Payload Handler
      handler = handler_for_response_code(response_code)
      payload = handler ? handler.new(io).parse_payload : nil

      {
        response_code: response_code,
        message_length: message_length,
        exchange_segment: exchange_segment,
        security_id: security_id,
        payload: payload
      }
    end

    def self.handler_for_response_code(response_code)
      case response_code
      when 2
        Handlers::TickerHandler
      when 4
        Handlers::QuoteHandler
      when 8
        Handlers::FullPacketHandler
      else
        nil # Unknown handler
      end
    end
  end
end


# File: app/services/option/chain_analyzer.rb
module Option
  class ChainAnalyzer
    def initialize(options_chain)
      @options_chain = options_chain.with_indifferent_access
    end

    def analyze
      {
        max_pain: calculate_max_pain,
        oi_support_resistance: analyze_oi_support_resistance,
        greeks_summary: analyze_greeks,
        price_action_trends: analyze_price_action
      }
    end

    private

    def calculate_max_pain
      strikes = @options_chain.dig(:data, :oc).keys
      strikes.map do |strike|
        oi_call = @options_chain.dig(:data, :oc, strike, "ce", :open_interest).to_i
        oi_put = @options_chain.dig(:data, :oc, strike, "pe", :open_interest).to_i
        [ strike, oi_call + oi_put ]
      end.min_by { |_strike, combined_oi| combined_oi }&.first
    end

    def analyze_oi_support_resistance
      calls = @options_chain.dig(:data, :oc).filter_map do |strike, data|
        { strike: strike.to_f, oi: data.dig("ce", :open_interest).to_i } if data["ce"]
      end
      puts = @options_chain.dig(:data, :oc).filter_map do |strike, data|
        { strike: strike.to_f, oi: data.dig("pe", :open_interest).to_i } if data["pe"]
      end

      {
        resistance: calls.max_by { |c| c[:oi] }&.dig(:strike),
        support: puts.max_by { |p| p[:oi] }&.dig(:strike)
      }
    end

    def analyze_greeks
      greeks = %w[delta gamma theta vega].each_with_object({}) do |greek, summary|
        values = @options_chain.dig(:data, :oc).values.flat_map do |data|
          [ data.dig("ce", greek), data.dig("pe", greek) ].compact
        end
        summary[:"#{greek}_avg"] = values.sum / values.size if values.any?
      end

      greeks
    end

    def analyze_price_action
      prices = @options_chain.dig(:data, :prices) || [] # Assume price data is available in the options chain
      volumes = @options_chain.dig(:data, :volumes) || [] # Assume volume data is available

      return { bullish: false, bearish: false, neutral: true } if prices.empty? || prices.size < 5

      # Calculate Moving Averages
      short_term_ma = moving_average(prices, 5) # 5-period MA
      long_term_ma = moving_average(prices, 20) # 20-period MA

      # Determine Trends
      bullish = short_term_ma.last > long_term_ma.last && increasing(prices) && increasing(volumes)
      bearish = short_term_ma.last < long_term_ma.last && decreasing(prices) && decreasing(volumes)
      neutral = !bullish && !bearish

      { bullish: bullish, bearish: bearish, neutral: neutral }
    end

    private

    def moving_average(data, period)
      return [] if data.size < period
      data.each_cons(period).map { |sub_array| sub_array.sum / period.to_f }
    end

    def increasing(data)
      data.each_cons(2).all? { |a, b| b >= a }
    end

    def decreasing(data)
      data.each_cons(2).all? { |a, b| b <= a }
    end
  end
end


# File: app/services/option/strategy_example_updater.rb
module Option
  class StrategyExampleUpdater
    def self.update_examples(option_chain, params)
      Strategy.all.each do |strategy|
        suggester = StrategySuggester.new(option_chain, params)
        example = suggester.generate_example(strategy.name)
        strategy.update(example: example) if example.is_a?(String)
      end
    end
  end
end


# File: app/services/option/strategy_suggester.rb
module Option
  class StrategySuggester
    def initialize(option_chain, params)
      @option_chain = option_chain.with_indifferent_access
      @params = params
      @current_price = @option_chain.dig(:data, :last_price) || 0
    end

    def suggest(criteria = {})
      analysis = criteria[:analysis]
      strategies = Strategy.all

      strategies = filter_by_outlook(strategies, criteria[:outlook])
      strategies = filter_by_volatility(strategies, criteria[:volatility])
      strategies = filter_by_risk(strategies, criteria[:risk])
      strategies = filter_by_option_preference(strategies, criteria[:option_preference])

      # Map filtered strategies with generated examples
      strategies.map do |strategy|
        strategy.as_json.merge(
          example: generate_example(strategy.name)
        )
      end
    end

    def generate_example(name)
      case name
      when "Bull Call Spread"
        call_buy = best_option("ce")
        call_sell = far_option("ce", "OTM")
        if call_buy && call_sell
          format_example("Buy #{call_buy[:symbol]} and Sell #{call_sell[:symbol]} @ ₹#{call_buy[:last_price]} - ₹#{call_sell[:last_price]}")
        end
      when "Bear Put Spread"
        put_buy = best_option("pe")
        put_sell = far_option("pe", "OTM")
        if put_buy && put_sell
          format_example("Buy #{put_buy[:symbol]} and Sell #{put_sell[:symbol]} @ ₹#{put_buy[:last_price]} - ₹#{put_sell[:last_price]}")
        end
      when "Short Straddle"
        call_option = best_option("ce")
        put_option = best_option("pe")
        if call_option && put_option
          format_example("Sell #{call_option[:symbol]} and Sell #{put_option[:symbol]} @ ₹#{call_option[:last_price]} + ₹#{put_option[:last_price]}")
        end
      when "Short Strangle"
        call_option = far_option("ce", "OTM")
        put_option = far_option("pe", "OTM")
        if call_option && put_option
          format_example("Sell #{call_option[:symbol]} and Sell #{put_option[:symbol]} @ ₹#{call_option[:last_price]} + ₹#{put_option[:last_price]}")
        end
      when "Protective Long Put"
        put_option = best_option("pe")
        if put_option
          format_example("Buy #{put_option[:symbol]} to hedge a long position @ ₹#{put_option[:last_price]}")
        end
      when "Iron Butterfly"
        call_sell = best_option("ce")
        put_sell = best_option("pe")
        call_buy = far_option("ce", "OTM")
        put_buy = far_option("pe", "OTM")
        if call_sell && put_sell && call_buy && put_buy
          format_example("Sell #{call_sell[:symbol]}, Sell #{put_sell[:symbol]}, Buy #{call_buy[:symbol]}, Buy #{put_buy[:symbol]}")
        end
      when "Iron Condor"
        call_sell = far_option("ce", "OTM")
        put_sell = far_option("pe", "OTM")
        call_buy = far_option("ce", "OTM")
        put_buy = far_option("pe", "OTM")
        if call_sell && put_sell && call_buy && put_buy
          format_example("Sell #{call_sell[:symbol]}, Sell #{put_sell[:symbol]}, Buy #{call_buy[:symbol]}, Buy #{put_buy[:symbol]} @ ₹#{call_sell[:last_price]} + ₹#{put_sell[:last_price]} - ₹#{call_buy[:last_price]} - ₹#{put_buy[:last_price]}")
        end
      when "Long Calendar Spread"
        long_option = best_option("ce")
        short_option = best_option("ce")
        if long_option && short_option
          format_example("Buy #{long_option[:symbol]} (Jan expiry) and Sell #{short_option[:symbol]} (Dec expiry) @ ₹#{long_option[:last_price]} - ₹#{short_option[:last_price]}")
        end
      else
        strategy = Strategy.find_by(name: name)
        strategy&.example || { note: "No dynamic example available for this strategy." }
      end
    end

    private

    def filter_by_outlook(strategies, outlook)
      return strategies unless outlook

      case outlook
      when "bullish"
        strategies.where(name: [ "Long Call", "Bull Call Spread", "Long Ratio Backspread", "Protective Long Put" ])
      when "bearish"
        strategies.where(name: [ "Long Put", "Bear Put Spread", "Short Straddle", "Short Strangle" ])
      else
        strategies
      end
    end

    def filter_by_volatility(strategies, volatility)
      return strategies unless volatility

      case volatility
      when "high"
        strategies.where(name: [ "Long Straddle", "Long Strangle", "Iron Butterfly", "Long Vega (Volatility Play)" ])
      when "low"
        strategies.where(name: [ "Short Straddle", "Short Strangle", "Iron Condor", "Iron Butterfly" ])
      else
        strategies
      end
    end

    def filter_by_risk(strategies, risk)
      return strategies unless risk

      case risk
      when "low"
        strategies.where(name: [ "Iron Condor", "Iron Butterfly", "Protective Long Put" ])
      when "moderate"
        strategies.where(name: [ "Bull Call Spread", "Bear Put Spread", "Long Calendar Spread", "Long Ratio Backspread" ])
      when "high"
        strategies.where(name: [ "Long Call", "Long Put", "Long Straddle", "Long Strangle" ])
      else
        strategies
      end
    end

    def filter_by_option_preference(strategies, preference)
      return strategies unless preference

      case preference
      when "buy"
        strategies.where(name: [ "Long Call", "Long Put", "Long Straddle", "Long Strangle", "Bull Call Spread", "Bear Put Spread", "Protective Long Put", "Long Vega (Volatility Play)" ])
      when "sell"
        strategies.where(name: [ "Short Straddle", "Short Strangle", "Iron Condor", "Iron Butterfly" ])
      else
        strategies
      end
    end

    def best_option(type)
      options = @option_chain.dig(:data, :oc).select { |strike, data| data[type].present? }
      return nil if options.empty?

      options.map do |strike, data|
        {
          strike_price: strike.to_f,
          last_price: data[type][:last_price],
          symbol: "#{@params[:index_symbol]}-#{strike.to_i}-#{type.upcase}"
        }
      end.min_by { |o| (o[:strike_price] - @current_price).abs }
    end

    def far_option(type, position)
      options = @option_chain.dig(:data, :oc).select { |strike, data| data[type].present? }
      return nil if options.empty?

      mapped_options = options.map do |strike, data|
        {
          strike_price: strike.to_f,
          last_price: data[type][:last_price],
          symbol: "#{@params[:index_symbol]}-#{strike.to_i}-#{type.upcase}"
        }
      end

      case position
      when "OTM"
        mapped_options.select { |o| o[:strike_price] > @current_price }.min_by { |o| o[:strike_price] - @current_price }
      when "ITM"
        mapped_options.select { |o| o[:strike_price] < @current_price }.max_by { |o| o[:strike_price] }
      else
        nil
      end
    end

    def format_example(action)
      {
        action: action,
        max_loss: "Premium Paid",
        max_profit: "Unlimited (in most cases)",
        note: "Example generated dynamically based on the current option chain."
      }
    end
  end
end


# File: app/services/option/suggest_strategy_service.rb
module Option
  class SuggestStrategyService
    def self.call(index_symbol:, expiry_date:, params:)
      instrument = Instrument.indices.find_by(underlying_symbol: index_symbol, segment: "I")
      raise "Invalid index symbol." if instrument.nil?

      option_chain = Dhanhq::API::Option.chain(
        UnderlyingScrip: instrument.security_id,
        UnderlyingSeg: instrument.exchange_segment,
        Expiry: expiry_date
      )
      analysis = ChainAnalyzer.new(option_chain).analyze
      suggester = StrategySuggester.new(option_chain, params)

      suggester.suggest(
        analysis: analysis,
        option_preference: params[:option_preference] || "both",
        outlook: params[:outlook],
        volatility: params[:volatility],
        risk: params[:risk]
      )
    end
  end
end


# File: app/services/order_management/order_processor.rb


# File: app/services/orders/strategies/base_strategy.rb
module Orders
  module Strategies
    class BaseStrategy
      attr_reader :alert, :instrument, :security_symbol, :exchange

      def initialize(alert)
        @alert = alert
        @security_symbol = alert[:ticker]
        @exchange = alert[:market] || "NSE"
      end

      def execute
        raise NotImplementedError, "#{self.class} must implement #execute"
      end

      private

      # Fetch the instrument record
      def instrument
        @instrument ||= Instrument.find_by!(
          exch_id: exchange,
          underlying_symbol: security_symbol
        )
      rescue ActiveRecord::RecordNotFound
        raise "Instrument not found for #{security_symbol} in #{exchange}"
      end

      # Fetch available funds
      def fetch_funds
        Dhanhq::API::Funds.balance["availabelBalance"].to_f
      end

      # Prepare common order parameters
      def dhan_order_params
        {
          transactionType: alert[:action].upcase,
          orderType: Dhanhq::Constants::MARKET,
          productType: default_product_type,
          validity: Dhanhq::Constants::DAY,
          securityId: instrument.security_id,
          exchangeSegment: map_exchange_segment(instrument.exch_id),
          quantity: calculate_quantity(alert[:current_price])
        }
      end

      # Map exchange segments dynamically
      def map_exchange_segment(exchange)
        Dhanhq::Constants::EXCHANGE_SEGMENTS.find { |seg| seg.include?(exchange) } ||
          raise("Unsupported exchange: #{exchange}")
      end

      def calculate_quantity(price)
        utilized_funds = fetch_funds * funds_utilization * leverage_factor

        lot_size = instrument.lot_size || 1
        max_quantity = (utilized_funds / price).floor

        quantity = (max_quantity / lot_size) * lot_size
        [ quantity, lot_size ].max
      end

      def leverage_factor
        1.0 # Default leverage is 1x
      end

      def funds_utilization
        0.3 # 30% utilization of funds
      end

      # Default product type (can be overridden by subclasses)
      def default_product_type
        Dhanhq::Constants::INTRA # Default to intraday
      end

      # Place an order using Dhan API
      def place_order(params)
        Dhanhq::API::Orders.place(params)
      rescue StandardError => e
        raise "Failed to place order: #{e.message}"
      end
    end
  end
end


# File: app/services/orders/strategies/intraday_stock_strategy.rb
module Orders
  module Strategies
    class IntradayStockStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params)
      end

      private

      def leverage_factor
        mis_detail = instrument.mis_detail
        mis_detail&.mis_leverage.to_i || 1 # Default to 1x if no MIS details found
      end

      def calculate_quantity(price)
        available_funds = fetch_funds * 0.3 # Use 30% of funds
        max_quantity = (available_funds / price).floor
        lot_size = instrument.lot_size || 1

        # Adjust quantity based on lot size
        quantity = (max_quantity / lot_size) * lot_size
        [ quantity, lot_size ].max
      end

      def default_product_type
        Dhanhq::Constants::INTRA # Override default to intraday
      end
    end
  end
end


# File: app/services/orders/strategies/options_strategy.rb
module Orders
  module Strategies
    class OptionsStrategy < BaseStrategy
      def execute
        strike_price = calculate_strike_price(alert[:current_price])
        option_type = determine_option_type(alert[:action].upcase)
        raise "Lot size not found for #{alert[:ticker]}" unless instrument.lot_size

        place_order(
          dhan_order_params.merge(
            productType: default_product_type,
            strikePrice: calculate_strike_price(alert[:current_price]),
            optionType: determine_option_type(alert[:action].upcase),
            expiryDate: nearest_expiry_date
          )
        )
      end

      private

      def default_product_type
        Dhanhq::Constants::CNC # Options are typically delivery
      end

      def calculate_strike_price(price)
        step = instrument.tick_size || 50 # Default to 50 if tick size is missing
        (price / step).round * step
      end

      def determine_option_type(action)
        case action
        when Dhanhq::Constants::BUY then "CE" # Call
        when Dhanhq::Constants::SELL then "PE" # Put
        else
          raise "Invalid action for options: #{action}"
        end
      end

      def nearest_expiry_date
        Instrument.where(
          underlying_symbol: instrument.underlying_symbol,
          expiry_flag: instrument.expiry_flag
        ).where("sm_expiry_date >= ?", Date.today)
         .order(:sm_expiry_date)
         .limit(1)
         .pluck(:sm_expiry_date)
         .first
      end
    end
  end
end


# File: app/services/orders/strategies/stock_order_strategy.rb
module Orders
  module Strategies
    class StockOrderStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params)
      end
    end
  end
end


# File: app/services/orders/strategies/swing_stock_strategy.rb
module Orders
  module Strategies
    class SwingStockStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params.merge(productType: Dhanhq::Constants::CNC))
      end

      private

      def default_product_type
        Dhanhq::Constants::CNC # Delivery-based product
      end
    end
  end
end


# File: app/services/orders/strategies/unified_options_strategy.rb
module Orders
  module Strategies
    class UnifiedOptionsStrategy < BaseStrategy
      def execute
        place_order(
          dhan_order_params.merge(
            strikePrice: calculate_strike_price(alert[:current_price]),
            quantity: calculate_quantity(alert[:current_price])
          )
        )
      end

      private

      def calculate_strike_price(price)
        step = instrument.tick_size || 50
        (price / step).round * step
      end
    end
  end
end


# File: app/services/order_service.rb
# app/services/order_service.rb
class OrderService
  def self.place_order(ticker:, action:, quantity:, price:, security_id:, trailing_stop_loss:)
    response = Dhanhq::API::Orders.place(
      transactionType: action.upcase,
      exchangeSegment: "NSE_EQ",
      productType: "CNC",
      orderType: "MARKET",
      securityId: security_id,
      quantity: quantity,
      price: price
    )

    Order.create(
      ticker: ticker,
      action: action,
      quantity: quantity,
      price: price,
      dhan_order_id: response["orderId"],
      dhan_status: response["orderStatus"],
      security_id: security_id,
      stop_loss_price: calculate_stop_loss(price, action, trailing_stop_loss),
      take_profit_price: calculate_take_profit(price)
    )
  end

  def self.calculate_stop_loss(price, action, trailing_stop_loss)
    action == "BUY" ? price - trailing_stop_loss : price + trailing_stop_loss
  end

  def self.calculate_take_profit(price)
    price * 1.02 # 1:2 profit-loss ratio
  end
end


# File: app/services/parsers/live_order_parser.rb
# app/services/parsers/live_order_parser.rb
module Parsers
  class LiveOrderParser
    REQUIRED_FIELDS = %w[
      Exchange Segment Source SecurityId ClientId ExchOrderNo OrderNo Product
      TxnType OrderType Validity RemainingQuantity Quantity TradedQty Price
      TriggerPrice TradedPrice AvgTradedPrice OrderDateTime ExchOrderTime
      LastUpdatedTime Remarks Status Symbol DisplayName Isin
    ].freeze

    def initialize(raw_data)
      @raw_data = raw_data
      @parsed_data = {}
    end

    def parse
      extract_data
      validate_data
      @parsed_data
    rescue StandardError => e
      Rails.logger.error("LiveOrderParser failed: #{e.message}")
      nil
    end

    private

    attr_reader :raw_data

    def extract_data
      @parsed_data = raw_data["Data"].slice(*REQUIRED_FIELDS)
    end

    def validate_data
      missing_fields = REQUIRED_FIELDS - @parsed_data.keys
      raise "Missing required fields: #{missing_fields.join(', ')}" unless missing_fields.empty?
    end
  end
end


# File: app/services/strategy_factory.rb
class StrategyFactory
  STRATEGY_MAP = {
    "Supertrend Strategy + Indicator" => Strategies::SupertrendStrategy,
    "VWAP Strategy" => Strategies::VWAPStrategy
  }.freeze

  def self.build(strategy_name)
    STRATEGY_MAP.fetch(strategy_name) { raise NotImplementedError, "Unknown strategy: #{strategy_name}" }.new
  end
end


# File: app/services/websocket_handlers/live_market_feed.rb
require "faye/websocket"
require "eventmachine"
require "json"

class LiveMarketFeed
  MAX_INSTRUMENTS_PER_BATCH = 100

  def initialize
    @url = build_url
    @subscribed_instruments = []
  end

  def connect
    EM.run do
      @ws = Faye::WebSocket::Client.new(@url)

      @ws.on(:open) do |_event|
        Rails.logger.info "[LiveMarketFeed] WebSocket connection established."
      end

      @ws.on(:message) do |event|
        handle_message(event.data)
      end

      @ws.on(:close) do |event|
        Rails.logger.warn "[LiveMarketFeed] WebSocket connection closed: Code=#{event.code}, Reason=#{event.reason}"
        EM.stop
      end

      @ws.on(:error) do |event|
        Rails.logger.error "[LiveMarketFeed] WebSocket encountered an error: #{event.message}"
      end
    end
  end

  def subscribe_to_instruments(instruments)
    instruments.each_slice(MAX_INSTRUMENTS_PER_BATCH) do |batch|
      subscription_message = {
        RequestCode: 15,
        InstrumentCount: batch.size,
        InstrumentList: batch.map do |inst|
          { ExchangeSegment: inst[:exchange_segment], SecurityId: inst[:security_id] }
        end
      }

      send_message(subscription_message)
    end

    @subscribed_instruments.concat(instruments)
    Rails.logger.info "[LiveMarketFeed] Subscribed to #{instruments.size} instruments."
  end

  def unsubscribe_all
    send_message({ RequestCode: 16 })
    @subscribed_instruments.clear
    Rails.logger.info "[LiveMarketFeed] Unsubscribed from all instruments."
  end

  private

  def build_url
    token = ENV.fetch("DHAN_ACCESS_TOKEN")
    client_id = ENV.fetch("DHAN_CLIENT_ID")
    "wss://api-feed.dhan.co?version=2&token=#{token}&clientId=#{client_id}&authType=2"
  end

  def send_message(message)
    if @ws
      @ws.send(message.to_json)
      Rails.logger.info "[LiveMarketFeed] Sent message: #{message}"
    else
      Rails.logger.error "[LiveMarketFeed] WebSocket connection not established. Cannot send message."
    end
  end

  def handle_message(data)
    begin
      # Market feed messages are in binary and need to be parsed
      parsed_data = MarketFeed::PacketParser.parse(data)
      MarketFeed::DataProcessor.new(parsed_data).process
    rescue JSON::ParserError => e
      Rails.logger.error "[LiveMarketFeed] Failed to parse message: #{e.message}. Raw data: #{data}"
    rescue StandardError => e
      Rails.logger.error "[LiveMarketFeed] Error processing message: #{e.message}"
    end
  end
end


# File: app/services/websocket_handlers/live_order_update.rb
require "faye/websocket"
require "eventmachine"
require "json"

class LiveOrderUpdate
  def initialize
    @url = "wss://api-order-update.dhan.co"
    @auth_message = {
      LoginReq: {
        MsgCode: 42,
        ClientId: ENV.fetch("DHAN_CLIENT_ID"),
        Token: ENV.fetch("DHAN_ACCESS_TOKEN")
      },
      UserType: "SELF"
    }
  end

  def connect
    EM.run do
      @ws = Faye::WebSocket::Client.new(@url)

      @ws.on(:open) do |_event|
        authenticate
        Rails.logger.info "[LiveOrderUpdate] WebSocket connection established."
      end

      @ws.on(:message) do |event|
        handle_message(event.data)
      end

      @ws.on(:close) do |event|
        Rails.logger.warn "[LiveOrderUpdate] WebSocket connection closed: Code=#{event.code}, Reason=#{event.reason}"
        EM.stop
      end

      @ws.on(:error) do |event|
        Rails.logger.error "[LiveOrderUpdate] WebSocket encountered an error: #{event.message}"
      end
    end
  end

  private

  def authenticate
    if @ws
      @ws.send(@auth_message.to_json)
      Rails.logger.info "[LiveOrderUpdate] Authentication message sent."
    else
      Rails.logger.error "[LiveOrderUpdate] WebSocket connection not established. Cannot authenticate."
    end
  end

  def handle_message(data)
    begin
      parsed_data = JSON.parse(data)

      # Ensure the message type is `order_alert`
      if parsed_data["Type"] == "order_alert"
        process_order_update(parsed_data["Data"])
      else
        Rails.logger.info "[LiveOrderUpdate] Unhandled message type: #{parsed_data['Type']}"
      end

    rescue JSON::ParserError => e
      Rails.logger.error "[LiveOrderUpdate] JSON parsing failed: #{e.message}. Raw data: #{data}"
    rescue StandardError => e
      Rails.logger.error "[LiveOrderUpdate] Error processing message: #{e.message}. Data: #{data}"
    end
  end

  def process_order_update(order_data)
    # Validate presence of required fields
    required_fields = %w[OrderNo Status Symbol Price TradedQty]
    missing_fields = required_fields - order_data.keys

    if missing_fields.any?
      Rails.logger.warn "[LiveOrderUpdate] Missing required fields: #{missing_fields.join(', ')}. Data: #{order_data}"
      return
    end

    # Example: Update the order in the database
    order = Order.find_by(dhan_order_id: order_data["OrderNo"])
    if order
      order.update(
        dhan_status: order_data["Status"],
        traded_price: order_data["TradedPrice"],
        remaining_quantity: order_data["RemainingQuantity"],
        traded_quantity: order_data["TradedQty"],
        last_updated_time: order_data["LastUpdatedTime"]
      )
      Rails.logger.info "[LiveOrderUpdate] Order updated successfully: OrderNo=#{order_data['OrderNo']}"
    else
      Rails.logger.warn "[LiveOrderUpdate] Order not found: OrderNo=#{order_data['OrderNo']}"
    end
  end
end


# File: app/validators/alert_validator.rb
class AlertValidator
  include ActiveModel::Model

  attr_accessor :ticker, :instrument_type, :action, :order_type, :current_position,
                :previous_position, :current_price, :high, :low, :volume, :time,
                :stop_loss, :take_profit, :trailing_stop_loss, :strategy_name, :strategy_id

  validates :ticker, :instrument_type, :action, :order_type, :strategy_name, :strategy_id, presence: true
  validates :instrument_type, inclusion: { in: %w[stock index] }
  validates :action, inclusion: { in: %w[buy sell] }
  validates :order_type, inclusion: { in: %w[market limit stop] }
  validates :current_price, :stop_loss, :take_profit, numericality: { greater_than: 0 }
  validates :volume, numericality: { only_integer: true, greater_than_or_equal_to: 0 }
  validates :time, presence: true

  def initialize(params = {})
    super(params.permit(:ticker, :instrument_type, :action, :order_type, :current_position,
                        :previous_position, :current_price, :high, :low, :volume, :time,
                        :stop_loss, :take_profit, :trailing_stop_loss, :strategy_name, :strategy_id))
  end
end


# File: app/views/layouts/mailer.html.erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>


# File: app/views/layouts/mailer.text.erb
<%= yield %>


# File: lib/tasks/import_mis_data.rake
# lib/tasks/import_mis_data.rake
namespace :data do
  desc "Import MIS Details from CSV"
  task import_mis: :environment do
    require "csv"

    # Reference the CSV file in the root folder
    file_path = Rails.root.join("mis_data.csv")

    # Check if the file exists
    unless File.exist?(file_path)
      puts "File not found at #{file_path}. Please make sure the file is present in the root folder."
      exit
    end

    CSV.foreach(file_path, headers: true) do |row|
      instruments = Instrument.where(underlying_symbol: row["Symbol / Scrip Name"]).where("segment = 'E'")

      next unless instruments.any?

      instruments.each do |instrument|
        if instrument
          m = MisDetail.create!(
            instrument: instrument,
            isin: row["ISIN"],
            mis_leverage: row["MIS(Intraday)"].delete("x").to_f,
            bo_leverage: row["BO(Bracket)"] ? row["BO(Bracket)"].delete("x").to_f : nil,
            co_leverage: row["CO(Cover)"] ? row["CO(Cover)"].delete("x").to_f : nil
          )

          pp m
        else
          Rails.logger.warn "Instrument not found for Symbol: #{row['Symbol / Scrip Name']}"
        end
      end
    end

    puts "MIS data imported successfully!"
  end
end


# File: lib/tasks/instrument_sync.rake
namespace :instruments do
  desc "Sync instruments from Dhan API"
  task sync: :environment do
    InstrumentSyncService.sync_instruments
  end
end


# File: lib/tasks/strategy_example_updater.rake
namespace :strategy do
  desc "Update strategy examples with current option chain data"
  task update_examples: :environment do
    option_chain = {} # Fetch or mock the option chain data
    params = { index_symbol: "Nifty" }

    Option::StrategyExampleUpdater.update_examples(option_chain, params)
    puts "Strategy examples updated successfully."
  end
end


# File: config/application.rb
require_relative "boot"

require "rails"
# Pick the frameworks you want:
require "active_model/railtie"
require "active_job/railtie"
require "active_record/railtie"
require "active_storage/engine"
require "action_controller/railtie"
require "action_mailer/railtie"
require "action_mailbox/engine"
require "action_text/engine"
require "action_view/railtie"
require "action_cable/engine"
# require "rails/test_unit/railtie"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module AlgoTradingApp
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 8.0

    # Please, add to the `ignore` list any other `lib` subdirectories that do
    # not contain `.rb` files, or that should not be reloaded or eager loaded.
    # Common ones are `templates`, `generators`, or `middleware`, for example.
    config.autoload_lib(ignore: %w[assets tasks])

    # Configuration for the application, engines, and railties goes here.
    #
    # These settings can be overridden in specific environments using the files
    # in config/environments, which are processed later.
    #
    # config.time_zone = "Central Time (US & Canada)"
    # config.eager_load_paths << Rails.root.join("extras")

    # Only loads a smaller set of middleware suitable for API only apps.
    # Middleware like session, flash, cookies can be added back manually.
    # Skip views, helpers and assets when generating a new resource.
    config.api_only = true
    config.hosts << /.*\.ngrok-free\.app/
  end
end


# File: config/boot.rb
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup" # Set up gems listed in the Gemfile.
require "bootsnap/setup" # Speed up boot time by caching expensive operations.


# File: config/cable.yml
# Async adapter only works within the same process, so for manually triggering cable updates from a console,
# and seeing results in the browser, you must do so from the web console (running inside the dev process),
# not a terminal started via bin/rails console! Add "console" to any action or any ERB template view
# to make the web console appear.
development:
  adapter: async

test:
  adapter: test

production:
  adapter: solid_cable
  connects_to:
    database:
      writing: cable
  polling_interval: 0.1.seconds
  message_retention: 1.day


# File: config/cache.yml
default: &default
  store_options:
    # Cap age of oldest cache entry to fulfill retention policies
    # max_age: <%= 60.days.to_i %>
    max_size: <%= 256.megabytes %>
    namespace: <%= Rails.env %>

development:
  <<: *default

test:
  <<: *default

production:
  database: cache
  <<: *default


# File: config/database.yml
# PostgreSQL. Versions 9.3 and up are supported.
#
# Install the pg driver:
#   gem install pg
# On macOS with Homebrew:
#   gem install pg -- --with-pg-config=/usr/local/bin/pg_config
# On Windows:
#   gem install pg
#       Choose the win32 build.
#       Install PostgreSQL and put its /bin directory on your path.
#
# Configure Using Gemfile
# gem "pg"
#
default: &default
  adapter: postgresql
  encoding: unicode
  # For details on connection pooling, see Rails configuration guide
  # https://guides.rubyonrails.org/configuring.html#database-pooling
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>


development:
  <<: *default
  database: algo_trading_app_development

  # The specified database role being used to connect to PostgreSQL.
  # To create additional roles in PostgreSQL see `$ createuser --help`.
  # When left blank, PostgreSQL will use the default role. This is
  # the same name as the operating system user running Rails.
  #username: algo_trading_app

  # The password associated with the PostgreSQL role (username).
  #password:

  # Connect on a TCP socket. Omitted by default since the client uses a
  # domain socket that doesn't need configuration. Windows does not have
  # domain sockets, so uncomment these lines.
  #host: localhost

  # The TCP port the server listens on. Defaults to 5432.
  # If your server runs on a different port number, change accordingly.
  #port: 5432

  # Schema search path. The server defaults to $user,public
  #schema_search_path: myapp,sharedapp,public

  # Minimum log levels, in increasing order:
  #   debug5, debug4, debug3, debug2, debug1,
  #   log, notice, warning, error, fatal, and panic
  # Defaults to warning.
  #min_messages: notice

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  <<: *default
  database: algo_trading_app_test

# As with config/credentials.yml, you never want to store sensitive information,
# like your database password, in your source code. If your source code is
# ever seen by anyone, they now have access to your database.
#
# Instead, provide the password or a full connection URL as an environment
# variable when you boot the app. For example:
#
#   DATABASE_URL="postgres://myuser:mypass@localhost/somedatabase"
#
# If the connection URL is provided in the special DATABASE_URL environment
# variable, Rails will automatically merge its configuration values on top of
# the values provided in this file. Alternatively, you can specify a connection
# URL environment variable explicitly:
#
#   production:
#     url: <%= ENV["MY_APP_DATABASE_URL"] %>
#
# Read https://guides.rubyonrails.org/configuring.html#configuring-a-database
# for a full overview on how database connection configuration can be specified.
#
production:
  primary: &primary_production
    <<: *default
    database: algo_trading_app_production
    username: algo_trading_app
    password: <%= ENV["ALGO_TRADING_APP_DATABASE_PASSWORD"] %>
  cache:
    <<: *primary_production
    database: algo_trading_app_production_cache
    migrations_paths: db/cache_migrate
  queue:
    <<: *primary_production
    database: algo_trading_app_production_queue
    migrations_paths: db/queue_migrate
  cable:
    <<: *primary_production
    database: algo_trading_app_production_cable
    migrations_paths: db/cable_migrate


# File: config/deploy.yml
# Name of your application. Used to uniquely configure containers.
service: algo_trading_app

# Name of the container image.
image: your-user/algo_trading_app

# Deploy to these servers.
servers:
  web:
    - 192.168.0.1
  # job:
  #   hosts:
  #     - 192.168.0.1
  #   cmd: bin/jobs

# Enable SSL auto certification via Let's Encrypt and allow for multiple apps on a single web server.
# Remove this section when using multiple web servers and ensure you terminate SSL at your load balancer.
#
# Note: If using Cloudflare, set encryption mode in SSL/TLS setting to "Full" to enable CF-to-app encryption.
proxy:
  ssl: true
  host: app.example.com

# Credentials for your image host.
registry:
  # Specify the registry server, if you're not using Docker Hub
  # server: registry.digitalocean.com / ghcr.io / ...
  username: your-user

  # Always use an access token rather than real password when possible.
  password:
    - KAMAL_REGISTRY_PASSWORD

# Inject ENV variables into containers (secrets come from .kamal/secrets).
env:
  secret:
    - RAILS_MASTER_KEY
  clear:
    # Run the Solid Queue Supervisor inside the web server's Puma process to do jobs.
    # When you start using multiple servers, you should split out job processing to a dedicated machine.
    SOLID_QUEUE_IN_PUMA: true

    # Set number of processes dedicated to Solid Queue (default: 1)
    # JOB_CONCURRENCY: 3

    # Set number of cores available to the application on each server (default: 1).
    # WEB_CONCURRENCY: 2

    # Match this to any external database server to configure Active Record correctly
    # Use algo_trading_app-db for a db accessory server on same machine via local kamal docker network.
    # DB_HOST: 192.168.0.2

    # Log everything from Rails
    # RAILS_LOG_LEVEL: debug

# Aliases are triggered with "bin/kamal <alias>". You can overwrite arguments on invocation:
# "bin/kamal logs -r job" will tail logs from the first server in the job section.
aliases:
  console: app exec --interactive --reuse "bin/rails console"
  shell: app exec --interactive --reuse "bash"
  logs: app logs -f
  dbc: app exec --interactive --reuse "bin/rails dbconsole"


# Use a persistent storage volume for sqlite database files and local Active Storage files.
# Recommended to change this to a mounted volume path that is backed up off server.
volumes:
  - "algo_trading_app_storage:/rails/storage"


# Bridge fingerprinted assets, like JS and CSS, between versions to avoid
# hitting 404 on in-flight requests. Combines all files from new and old
# version inside the asset_path.
asset_path: /rails/public/assets

# Configure the image builder.
builder:
  arch: amd64

  # # Build image via remote server (useful for faster amd64 builds on arm64 computers)
  # remote: ssh://docker@docker-builder-server
  #
  # # Pass arguments and secrets to the Docker build process
  # args:
  #   RUBY_VERSION: ruby-3.3.4
  # secrets:
  #   - GITHUB_TOKEN
  #   - RAILS_MASTER_KEY

# Use a different ssh user than root
# ssh:
#   user: app

# Use accessory services (secrets come from .kamal/secrets).
# accessories:
#   db:
#     image: mysql:8.0
#     host: 192.168.0.2
#     # Change to 3306 to expose port to the world instead of just local network.
#     port: "127.0.0.1:3306:3306"
#     env:
#       clear:
#         MYSQL_ROOT_HOST: '%'
#       secret:
#         - MYSQL_ROOT_PASSWORD
#     files:
#       - config/mysql/production.cnf:/etc/mysql/my.cnf
#       - db/production.sql:/docker-entrypoint-initdb.d/setup.sql
#     directories:
#       - data:/var/lib/mysql
#   redis:
#     image: redis:7.0
#     host: 192.168.0.2
#     port: 6379
#     directories:
#       - data:/data


# File: config/environment.rb
# Load the Rails application.
require_relative "application"

# Initialize the Rails application.
Rails.application.initialize!


# File: config/environments/development.rb
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Make code changes take effect immediately without server restart.
  config.enable_reloading = true

  # Do not eager load code on boot.
  config.eager_load = false

  # Show full error reports.
  config.consider_all_requests_local = true

  # Enable server timing.
  config.server_timing = true

  # Enable/disable Action Controller caching. By default Action Controller caching is disabled.
  # Run rails dev:cache to toggle Action Controller caching.
  if Rails.root.join("tmp/caching-dev.txt").exist?
    config.public_file_server.headers = { "cache-control" => "public, max-age=#{2.days.to_i}" }
  else
    config.action_controller.perform_caching = false
  end

  # Change to :null_store to avoid any caching.
  config.cache_store = :memory_store

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Don't care if the mailer can't send.
  config.action_mailer.raise_delivery_errors = false

  # Make template changes take effect immediately.
  config.action_mailer.perform_caching = false

  # Set localhost to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "localhost", port: 3000 }

  # Print deprecation notices to the Rails logger.
  config.active_support.deprecation = :log

  # Raise an error on page load if there are pending migrations.
  config.active_record.migration_error = :page_load

  # Highlight code that triggered database queries in logs.
  config.active_record.verbose_query_logs = true

  # Append comments with runtime information tags to SQL queries in logs.
  config.active_record.query_log_tags_enabled = true

  # Highlight code that enqueued background job in logs.
  config.active_job.verbose_enqueue_logs = true

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  config.action_view.annotate_rendered_view_with_filenames = true

  # Uncomment if you wish to allow Action Cable access from any origin.
  # config.action_cable.disable_request_forgery_protection = true

  # Raise error when a before_action's only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true

  # Apply autocorrection by RuboCop to files generated by `bin/rails generate`.
  # config.generators.apply_rubocop_autocorrect_after_generate!
end


# File: config/environments/production.rb
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Code is not reloaded between requests.
  config.enable_reloading = false

  # Eager load code on boot for better performance and memory savings (ignored by Rake tasks).
  config.eager_load = true

  # Full error reports are disabled.
  config.consider_all_requests_local = false

  # Cache assets for far-future expiry since they are all digest stamped.
  config.public_file_server.headers = { "cache-control" => "public, max-age=#{1.year.to_i}" }

  # Enable serving of images, stylesheets, and JavaScripts from an asset server.
  # config.asset_host = "http://assets.example.com"

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Assume all access to the app is happening through a SSL-terminating reverse proxy.
  config.assume_ssl = true

  # Force all access to the app over SSL, use Strict-Transport-Security, and use secure cookies.
  config.force_ssl = true

  # Skip http-to-https redirect for the default health check endpoint.
  # config.ssl_options = { redirect: { exclude: ->(request) { request.path == "/up" } } }

  # Log to STDOUT with the current request id as a default log tag.
  config.log_tags = [ :request_id ]
  config.logger   = ActiveSupport::TaggedLogging.logger(STDOUT)

  # Change to "debug" to log everything (including potentially personally-identifiable information!)
  config.log_level = ENV.fetch("RAILS_LOG_LEVEL", "info")

  # Prevent health checks from clogging up the logs.
  config.silence_healthcheck_path = "/up"

  # Don't log any deprecations.
  config.active_support.report_deprecations = false

  # Replace the default in-process memory cache store with a durable alternative.
  config.cache_store = :solid_cache_store

  # Replace the default in-process and non-durable queuing backend for Active Job.
  config.active_job.queue_adapter = :solid_queue
  config.solid_queue.connects_to = { database: { writing: :queue } }

  # Ignore bad email addresses and do not raise email delivery errors.
  # Set this to true and configure the email server for immediate delivery to raise delivery errors.
  # config.action_mailer.raise_delivery_errors = false

  # Set host to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "example.com" }

  # Specify outgoing SMTP server. Remember to add smtp/* credentials via rails credentials:edit.
  # config.action_mailer.smtp_settings = {
  #   user_name: Rails.application.credentials.dig(:smtp, :user_name),
  #   password: Rails.application.credentials.dig(:smtp, :password),
  #   address: "smtp.example.com",
  #   port: 587,
  #   authentication: :plain
  # }

  # Enable locale fallbacks for I18n (makes lookups for any locale fall back to
  # the I18n.default_locale when a translation cannot be found).
  config.i18n.fallbacks = true

  # Do not dump schema after migrations.
  config.active_record.dump_schema_after_migration = false

  # Only use :id for inspections in production.
  config.active_record.attributes_for_inspect = [ :id ]

  # Enable DNS rebinding protection and other `Host` header attacks.
  # config.hosts = [
  #   "example.com",     # Allow requests from example.com
  #   /.*\.example\.com/ # Allow requests from subdomains like `www.example.com`
  # ]
  #
  # Skip DNS rebinding protection for the default health check endpoint.
  # config.host_authorization = { exclude: ->(request) { request.path == "/up" } }
end


# File: config/environments/test.rb
# The test environment is used exclusively to run your application's
# test suite. You never need to work with it otherwise. Remember that
# your test database is "scratch space" for the test suite and is wiped
# and recreated between test runs. Don't rely on the data there!

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # While tests run files are not watched, reloading is not necessary.
  config.enable_reloading = false

  # Eager loading loads your entire application. When running a single test locally,
  # this is usually not necessary, and can slow down your test suite. However, it's
  # recommended that you enable it in continuous integration systems to ensure eager
  # loading is working properly before deploying your code.
  config.eager_load = ENV["CI"].present?

  # Configure public file server for tests with cache-control for performance.
  config.public_file_server.headers = { "cache-control" => "public, max-age=3600" }

  # Show full error reports.
  config.consider_all_requests_local = true
  config.cache_store = :null_store

  # Render exception templates for rescuable exceptions and raise for other exceptions.
  config.action_dispatch.show_exceptions = :rescuable

  # Disable request forgery protection in test environment.
  config.action_controller.allow_forgery_protection = false

  # Store uploaded files on the local file system in a temporary directory.
  config.active_storage.service = :test

  # Tell Action Mailer not to deliver emails to the real world.
  # The :test delivery method accumulates sent emails in the
  # ActionMailer::Base.deliveries array.
  config.action_mailer.delivery_method = :test

  # Set host to be used by links generated in mailer templates.
  config.action_mailer.default_url_options = { host: "example.com" }

  # Print deprecation notices to the stderr.
  config.active_support.deprecation = :stderr

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  # config.action_view.annotate_rendered_view_with_filenames = true

  # Raise error when a before_action's only/except options reference missing actions.
  config.action_controller.raise_on_missing_callback_actions = true
end


# File: config/initializers/cors.rb
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins "*" # Update '*' with specific domains for security, e.g., 'http://localhost:3000'

    resource "*",
             headers: :any,
             methods: [ :get, :post, :put, :patch, :delete, :options, :head ]
  end
end


# File: config/initializers/dhanhq.rb
require "dhanhq"

Dhanhq.configure do |config|
  config.client_id = ENV["DHAN_CLIENT_ID"]
  config.access_token = ENV["DHAN_ACCESS_TOKEN"]
end


# File: config/initializers/filter_parameter_logging.rb
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += [
  :passw, :email, :secret, :token, :_key, :crypt, :salt, :certificate, :otp, :ssn, :cvv, :cvc
]


# File: config/initializers/inflections.rb
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end


# File: config/initializers/websockets.rb
# config/initializers/websockets.rb
# Thread.new do
#   market_feed = LiveMarketFeed.new(token: ENV["DHAN_ACCESS_TOKEN"], client_id: ENV["DHAN_CLIENT_ID"])
#   market_feed.connect

#   order_update = LiveOrderUpdate.new(token: ENV["DHAN_ACCESS_TOKEN"], client_id: ENV["DHAN_CLIENT_ID"])
#   order_update.connect
# end


# File: config/locales/en.yml
# Files in the config/locales directory are used for internationalization and
# are automatically loaded by Rails. If you want to use locales other than
# English, add the necessary files in this directory.
#
# To use the locales, use `I18n.t`:
#
#     I18n.t "hello"
#
# In views, this is aliased to just `t`:
#
#     <%= t("hello") %>
#
# To use a different locale, set it with `I18n.locale`:
#
#     I18n.locale = :es
#
# This would use the information in config/locales/es.yml.
#
# To learn more about the API, please read the Rails Internationalization guide
# at https://guides.rubyonrails.org/i18n.html.
#
# Be aware that YAML interprets the following case-insensitive strings as
# booleans: `true`, `false`, `on`, `off`, `yes`, `no`. Therefore, these strings
# must be quoted to be interpreted as strings. For example:
#
#     en:
#       "yes": yup
#       enabled: "ON"

en:
  hello: "Hello world"


# File: config/puma.rb
# This configuration file will be evaluated by Puma. The top-level methods that
# are invoked here are part of Puma's configuration DSL. For more information
# about methods provided by the DSL, see https://puma.io/puma/Puma/DSL.html.
#
# Puma starts a configurable number of processes (workers) and each process
# serves each request in a thread from an internal thread pool.
#
# You can control the number of workers using ENV["WEB_CONCURRENCY"]. You
# should only set this value when you want to run 2 or more workers. The
# default is already 1.
#
# The ideal number of threads per worker depends both on how much time the
# application spends waiting for IO operations and on how much you wish to
# prioritize throughput over latency.
#
# As a rule of thumb, increasing the number of threads will increase how much
# traffic a given process can handle (throughput), but due to CRuby's
# Global VM Lock (GVL) it has diminishing returns and will degrade the
# response time (latency) of the application.
#
# The default is set to 3 threads as it's deemed a decent compromise between
# throughput and latency for the average Rails application.
#
# Any libraries that use a connection pool or another resource pool should
# be configured to provide at least as many connections as the number of
# threads. This includes Active Record's `pool` parameter in `database.yml`.
threads_count = ENV.fetch("RAILS_MAX_THREADS", 3)
threads threads_count, threads_count

# Specifies the `port` that Puma will listen on to receive requests; default is 3000.
port ENV.fetch("PORT", 3000)

# Allow puma to be restarted by `bin/rails restart` command.
plugin :tmp_restart

# Run the Solid Queue supervisor inside of Puma for single-server deployments
plugin :solid_queue if ENV["SOLID_QUEUE_IN_PUMA"]

# Specify the PID file. Defaults to tmp/pids/server.pid in development.
# In other environments, only set the PID file if requested.
pidfile ENV["PIDFILE"] if ENV["PIDFILE"]


# File: config/queue.yml
default: &default
  dispatchers:
    - polling_interval: 1
      batch_size: 500
  workers:
    - queues: "*"
      threads: 3
      processes: <%= ENV.fetch("JOB_CONCURRENCY", 1) %>
      polling_interval: 0.1

development:
  <<: *default

test:
  <<: *default

production:
  <<: *default


# File: config/recurring.yml
# production:
#   periodic_cleanup:
#     class: CleanSoftDeletedRecordsJob
#     queue: background
#     args: [ 1000, { batch_size: 500 } ]
#     schedule: every hour
#   periodic_command:
#     command: "SoftDeletedRecord.due.delete_all"
#     priority: 2
#     schedule: at 5am every day


# File: config/routes.rb
Rails.application.routes.draw do
  get "options/suggest_strategies"
  resources :mis_details
  namespace :webhooks do
    post :tradingview, to: "alerts#create"
  end

  resources :instruments
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html
  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
  # Can be used by load balancers and uptime monitors to verify that the app is live.
  get "up" => "rails/health#show", as: :rails_health_check

  # Defines the root path route ("/")
  # root "posts#index"
end


# File: config/storage.yml
test:
  service: Disk
  root: <%= Rails.root.join("tmp/storage") %>

local:
  service: Disk
  root: <%= Rails.root.join("storage") %>

# Use bin/rails credentials:edit to set the AWS secrets (as aws:access_key_id|secret_access_key)
# amazon:
#   service: S3
#   access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
#   secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
#   region: us-east-1
#   bucket: your_own_bucket-<%= Rails.env %>

# Remember not to checkin your GCS keyfile to a repository
# google:
#   service: GCS
#   project: your_project
#   credentials: <%= Rails.root.join("path/to/gcs.keyfile") %>
#   bucket: your_own_bucket-<%= Rails.env %>

# Use bin/rails credentials:edit to set the Azure Storage secret (as azure_storage:storage_access_key)
# microsoft:
#   service: AzureStorage
#   storage_account_name: your_account_name
#   storage_access_key: <%= Rails.application.credentials.dig(:azure_storage, :storage_access_key) %>
#   container: your_container_name-<%= Rails.env %>

# mirror:
#   service: Mirror
#   primary: local
#   mirrors: [ amazon, google, microsoft ]


