# File: app/controllers/application_controller.rb
class ApplicationController < ActionController::API
end


# File: app/controllers/instruments_controller.rb
class InstrumentsController < ApplicationController
end


# File: app/controllers/mis_details_controller.rb
class MisDetailsController < ApplicationController
end


# File: app/controllers/options_controller.rb
class OptionsController < ApplicationController
  def suggest_strategies
    strategies = Option::SuggestStrategyService.call(
      index_symbol: params[:index_symbol],
      expiry_date: params[:expiry_date],
      params: params
    )
    render json: { strategies: strategies }
  rescue StandardError => e
    render json: { error: e.message }, status: :unprocessable_entity
  end
end


# File: app/controllers/orders_controller.rb


# File: app/controllers/webhooks/alerts_controller.rb
class Webhooks::AlertsController < ApplicationController
  def create
    alert = Alert.new(alert_params)

    if valid_alert?(alert_params)
      if alert.save
        # Process the alert asynchronously
        AlertProcessor.call(alert)

        render json: { message: "Alert processed successfully", alert: alert }, status: :ok
      else
        render json: { error: "Failed to save alert", details: alert.errors.full_messages }, status: :unprocessable_entity
      end
    else
      render json: { error: "Invalid or delayed alert" }, status: :unprocessable_entity
    end
  end

  private

  def alert_params
    params.require(:alert).permit(
      :ticker, :instrument_type, :order_type, :current_position, :previous_position, :current_price,
      :high, :low, :volume, :time, :chart_interval, :stop_loss, :take_profit, :trailing_stop_loss,
      :strategy_name, :strategy_id, :action, :strategy_type, :exchange
    )
  end

  # Validate alert timestamp to ensure it's not delayed beyond 60 seconds
  def valid_alert?(alert)
    Time.zone.now - Time.parse(alert[:time]) < 60 || true
  rescue ArgumentError
    false
  end

  def parse_payload
    payload = JSON.parse(request.body.read)
    AlertValidator.new(payload)
  end
end


# File: app/jobs/application_job.rb
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end


# File: app/jobs/csv_import_job.rb
class CsvImportJob < ApplicationJob
  queue_as :default

  require "open-uri"

  def perform(*args)
    file_path = download_file(file_url)
    CsvImporter.import(file_path)
    cleanup_file(file_path)
  end

  private

  # Downloads the file from the given URL
  def download_file(url = ENV["CSV_FILE_URL"])
    file_path = Rails.root.join("tmp", "api-scrip-master-detailed.csv")
    File.write(file_path, URI.open(url).read)
    file_path
  end

  # Deletes the file after import
  def cleanup_file(file_path)
    File.delete(file_path) if File.exist?(file_path)
  end
end


# File: app/jobs/trailing_stop_loss_job.rb
class TrailingStopLossJob < ApplicationJob
  queue_as :default

  def perform
    positions = Dhanhq::API::Portfolio.positions

    positions.each do |position|
      next if position["positionType"] == "CLOSED"

      new_stop_loss = calculate_new_stop_loss(position)

      update_stop_loss_order(position, new_stop_loss) if new_stop_loss != position["stopLoss"]
    end
  rescue StandardError => e
    Rails.logger.error("TrailingStopLossJob failed: #{e.message}")
  end

  private

  def fetch_latest_price(ticker)
    # Fetch from WebSocket or other market feed
  end

  def calculate_new_stop_loss(position)
    entry_price = position["entryPrice"].to_f
    current_price = position["lastTradedPrice"].to_f
    trailing_amount = position["trailingStopLoss"].to_f

    return position["stopLoss"] if current_price <= entry_price

    position["positionType"] == "LONG" ? current_price - trailing_amount : current_price + trailing_amount
  end

  def update_stop_loss_order(position, new_stop_loss)
    Dhanhq::API::Orders.modify(position["orderId"], triggerPrice: new_stop_loss)
  rescue StandardError => e
    Rails.logger.error("Failed to update stop-loss for position #{position['tradingSymbol']}: #{e.message}")
  end
end


# File: app/jobs/update_strategy_examples_job.rb
class UpdateStrategyExamplesJob < ApplicationJob
  queue_as :default

  def perform(option_chain, params)
    Option::StrategyExampleUpdater.update_examples(option_chain, params)
  end
end


# File: app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end


# File: app/models/alert.rb
class Alert < ApplicationRecord
  validates :ticker, :instrument_type, :order_type, :current_price, :time, :strategy_name, :strategy_id, presence: true
  validates :instrument_type, inclusion: { in: %w[stock index crypto forex] }
  validates :order_type, inclusion: { in: %w[market limit stop] }
  validates :current_price, :high, :low, :volume, :stop_loss, :take_profit, :trailing_stop_loss, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true

  enum :status, { pending: "pending", processed: "processed", failed: "failed" }
end


# File: app/models/application_record.rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end


# File: app/models/derivative.rb
class Derivative < ApplicationRecord
  # Associations
  belongs_to :instrument

  # Validations
  validates :instrument, presence: true
  validates :strike_price, :option_type, :expiry_date, presence: true
end


# File: app/models/instrument.rb
class Instrument < ApplicationRecord
  # Associations
  has_one :mis_detail, dependent: :destroy
  has_many :derivatives, dependent: :destroy
  has_many :margin_requirements, dependent: :destroy
  has_many :order_features, dependent: :destroy

  enum :exchange, { nse: "NSE", bse: "BSE" }
  enum :segment, { index: "I", equity: "E", currency: "C", derivatives: "D" }, prefix: true
  enum :instrument, {
    index: "INDEX",
    futures_index: "FUTIDX",
    options_index: "OPTIDX",
    equity: "EQUITY",
    futures_stock: "FUTSTK",
    options_stock: "OPTSTK",
    futures_currency: "FUTCUR",
    options_currency: "OPTCUR"
  }, prefix: true


  # Validations
  validates :security_id, presence: true

  # Scopes
  # scope :equities, -> { where(instrument: equities) }
  # scope :indices, -> { where(instrument: :index) }
  # scope :currencies, -> { where(segment: "C") }
  scope :expiring_soon, -> { where(expiry_flag: "1") }

  # API Methods
  def ltp
    response = Dhanhq::API::MarketFeed.ltp(exch_segment_enum)
    response["status"] == "success" ? response.dig("data", exchange_segment, security_id.to_s, "last_price") : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP for Instrument #{id}: #{e.message}")
    nil
  end

  def ohlc
    response = Dhanhq::API::MarketFeed.ohlc(exch_segment_enum)
    response["status"] == "success" ? response.dig("data", exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch OHLC for Instrument #{id}: #{e.message}")
    nil
  end

  def depth
    response = Dhanhq::API::MarketFeed.quote(exch_segment_enum)
    response["status"] == "success" ? response.dig("data", exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Depth for Instrument #{id}: #{e.message}")
    nil
  end

  def fetch_option_chain(expiry)
    response = Dhanhq::API::Option.chain(
      UnderlyingScrip: security_id.to_i,
      UnderlyingSeg: exchange_segment,
      Expiry: expiry
    )
    response["data"]
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Option Chain for Instrument #{id}: #{e.message}")
    nil
  end

  def expiry_list
    response = Dhanhq::API::Option.expiry_list(
      UnderlyingScrip: security_id,
      UnderlyingSeg: exchange_segment,
    )
    response["data"]
  end

  # Generate `exchange_segment` dynamically
  def exchange_segment
    case [ exchange.to_sym, segment.to_sym ]
    when [ :nse, :index ] then "IDX_I"
    when [ :bse, :index ] then "IDX_I"
    when [ :nse, :equity ] then "NSE_EQ"
    when [ :bse, :equity ] then "BSE_EQ"
    when [ :nse, :derivatives ] then "NSE_FNO"
    when [ :bse, :derivatives ] then "BSE_FNO"
    when [ :nse, :currency ] then "NSE_CURRENCY"
    when [ :bse, :currency ] then "BSE_CURRENCY"
    else
      raise "Unsupported exchange and segment combination: #{exchange}, #{segment}"
    end
  end

  private

  def exch_segment_enum
    { exchange_segment => [ security_id.to_i ] }
  end
end


# File: app/models/margin_requirement.rb
class MarginRequirement < ApplicationRecord
  # Associations
  belongs_to :instrument

  # Validations
  validates :instrument, presence: true
  validates :buy_co_min_margin_per, :sell_co_min_margin_per, numericality: { greater_than_or_equal_to: 0 }, allow_nil: true
end


# File: app/models/mis_detail.rb
class MisDetail < ApplicationRecord
  belongs_to :instrument

  validates :mis_leverage, presence: true
end


# File: app/models/order_feature.rb
class OrderFeature < ApplicationRecord
  # Associations
  belongs_to :instrument

  # Validations
  validates :instrument, presence: true
  validates :bracket_flag, :cover_flag, inclusion: { in: [ "Y", "N" ] }, allow_nil: true
end


# File: app/models/order.rb
class Order < ApplicationRecord
  # Validations
  validates :ticker, :action, :quantity, :status, presence: true
  validates :quantity, numericality: { only_integer: true, greater_than: 0 }
end


# File: app/models/position.rb
class Position < ApplicationRecord
  # Validations
  validates :ticker, :action, :quantity, :entry_price, :stop_loss_price, :take_profit_price, presence: true
  validates :quantity, numericality: { only_integer: true, greater_than: 0 }
end


# File: app/models/strategy.rb
class Strategy < ApplicationRecord
  validates :name, presence: true, uniqueness: true
end


# File: app/services/alert_processor.rb
class AlertProcessor < ApplicationService
  def initialize(alert)
    @alert = alert
  end

  def call
    handle_open_position

    strategy = select_strategy
    raise "Strategy not found for instrument type: #{@alert[:instrument_type]}" unless strategy

    strategy.execute

    # setup_trailing_stop_loss(order_response) if order_response&.dig("orderId")

    @alert.update(status: "processed")
  rescue StandardError => e
    @alert.update(status: "failed", error_message: e.message)
    Rails.logger.error("Failed to process alert #{@alert.id}: #{e.message}")
  end

  private

  attr_reader :alert

  # Handle open positions and close them if profitable
  def handle_open_position
    position = fetch_open_position

    return unless position && position_profitable?(position)

    if opposite_signal?(position)
      if position_profitable?(position)
        close_position(position)
      elsif risk_reward_hit?(position)
        close_position(position)
      end
    end
  end

  def fetch_open_position
    positions = Dhanhq::API::Portfolio.positions
    positions.find { |pos| pos["tradingSymbol"] == alert[:ticker] && pos["positionType"] != "CLOSED" }
  end


  def position_profitable?(position)
    position["unrealizedProfit"].to_f > 20.00
  end

  def risk_reward_hit?(position)
    entry_price = position["entryPrice"].to_f
    target_price = entry_price + (entry_price - position["stopLoss"].to_f) * 2
    current_price = position["lastTradedPrice"].to_f
    current_price >= target_price
  end

  def opposite_signal?(position)
    alert[:action].upcase != position["positionType"]
  end

  def close_position(position)
    order_data = {
      transactionType: position["positionType"] == "LONG" ? "SELL" : "BUY",
      exchangeSegment: position["exchangeSegment"],
      productType: position["productType"],
      orderType: "MARKET",
      validity: "DAY",
      securityId: position["securityId"],
      quantity: position["netQty"]
    }

    Dhanhq::API::Orders.place(order_data)
  rescue StandardError => e
    raise "Failed to close position for #{position['tradingSymbol']}: #{e.message}"
  end

  def select_strategy
    strategy_suffix = alert[:strategy_id]&.split("_")&.last

    case alert[:instrument_type].downcase
    when "stock"
      case strategy_suffix
      when "intraday" then Orders::Strategies::IntradayStockStrategy.new(alert)
      when "swing"    then Orders::Strategies::SwingStockStrategy.new(alert)
      when "long_term" then Orders::Strategies::StockOrderStrategy.new(alert)
      else
        raise "Unsupported stock strategy: #{strategy_suffix}"
      end
    when "index"
      case strategy_suffix
      when "intraday" then Orders::Strategies::IntradayIndexStrategy.new(alert)
      when "swing"    then Orders::Strategies::SwingIndexStrategy.new(alert)
      else
        raise "Unsupported index strategy: #{strategy_suffix}"
      end
    when "option"
      case strategy_suffix
      when "intraday" then Orders::Strategies::IntradayOptionsStrategy.new(alert)
      when "swing"    then Orders::Strategies::SwingOptionsStrategy.new(alert)
      else
        raise "Unsupported options strategy: #{strategy_suffix}"
      end
    when "future"
      case strategy_suffix
      when "intraday" then Orders::Strategies::IntradayFuturesStrategy.new(alert)
      when "swing"    then Orders::Strategies::SwingFuturesStrategy.new(alert)
      else
        raise "Unsupported futures strategy: #{strategy_suffix}"
      end
    else
      raise "Unsupported instrument type: #{alert[:instrument_type]}"
    end
  end
end


# File: app/services/algo_trading/order_manager.rb
# app/services/algo_trading/order_manager.rb
module AlgoTrading
  class OrderManager
    def initialize
      @market_feed_handler = WebsocketHandlers::MarketFeedHandler.new
      @order_update_handler = WebsocketHandlers::OrderUpdateHandler.new
    end

    def start
      Thread.new { @market_feed_handler.listen }
      Thread.new { @order_update_handler.listen }
    end

    def place_order(alert, market_data)
      order_params = {
        transactionType: alert[:action].upcase,
        orderType: "LIMIT",
        price: calculate_limit_price(market_data),
        securityId: alert[:security_id],
        quantity: calculate_quantity(alert[:current_price]),
        productType: "INTRA"
      }
      Dhanhq::API::Orders.place(order_params)
    end

    def calculate_limit_price(market_data)
      # Use precision of 0.05 for limit orders
      (market_data["last_price"] * 0.95).round(2)
    end

    def calculate_quantity(price)
      available_funds = Dhanhq::API::Funds.balance["availabelBalance"].to_f
      (available_funds * 0.3 / price).floor
    end
  end
end


# File: app/services/algo_trading/stop_loss_manager.rb
# app/services/algo_trading/stop_loss_manager.rb
module AlgoTrading
  class StopLossManager
    def initialize
      @order_update_handler = WebsocketHandlers::OrderUpdateHandler.new
    end

    def adjust_stop_loss(order, market_data)
      new_stop_loss = calculate_stop_loss(market_data["last_price"])
      Dhanhq::API::Orders.modify(order_id: order[:id], stop_loss_price: new_stop_loss)
    end

    def calculate_stop_loss(current_price)
      (current_price * 0.98).round(2) # 2% below current price
    end
  end
end


# File: app/services/application_service.rb
class ApplicationService
  def self.call(*args, &block)
    new(*args, &block).call
  end

  # Optional: Override this to define a custom error handler in subclasses
  def handle_error(error)
    raise error
  end
end


# File: app/services/csv_importer.rb
require "csv"
require "open-uri"

class CsvImporter
  CSV_URL = "https://images.dhan.co/api-data/api-scrip-master-detailed.csv".freeze
  VALID_EXCHANGES = %w[NSE BSE].freeze
  VALID_SEGMENTS = %w[C D E I].freeze
  VALID_INSTRUMENTS = %w[FUTCUR OPTCUR OPTIDX FUTIDX OPTSTK FUTSTK EQUITY INDEX].freeze
  VALID_BUY_SELL_INDICATOR = %w[A].freeze # A means both Buy and Sell are allowed

  def self.import
    file_path = download_csv
    csv_data = filter_csv_data(CSV.read(file_path, headers: true))

    debugger
    # Import Instruments
    import_instruments(csv_data)

    # Import Derivatives
    import_derivatives(csv_data)

    # Import Margin Requirements
    import_margin_requirements(csv_data)

    # Import Order Features
    import_order_features(csv_data)

    # Cleanup temporary file
    # File.delete(file_path) if File.exist?(file_path)

    puts "CSV Import completed successfully!"
  end

  private

  def self.download_csv
    puts "Downloading CSV from #{CSV_URL}..."
    tmp_file = Rails.root.join("tmp", "api-scrip-master-detailed.csv")
    File.open(tmp_file, "wb") do |file|
      file.write(URI.open(CSV_URL).read)
    end
    puts "CSV downloaded to #{tmp_file}"
    tmp_file
  end

  def self.filter_csv_data(csv_data)
    puts "Filtering CSV data..."
    csv_data.select do |row|
      valid_instrument?(row) && valid_buy_sell_indicator?(row) && valid_expiry_date?(row)
    end
  end

  def self.import_instruments(csv_data)
    puts "Importing Instruments..."
    csv_data.each do |row|
      next if Instrument.find_by(security_id: row["SECURITY_ID"], symbol_name: row["SYMBOL_NAME"])

      puts "Importing Instrument: #{row["DISPLAY_NAME"]} (#{row["INSTRUMENT"]})"

      instrument = Instrument.find_or_initialize_by(security_id: row["SECURITY_ID"])
      instrument.update!(
        isin: row["ISIN"],
        instrument: row["INSTRUMENT"],
        underlying_symbol: row["UNDERLYING_SYMBOL"],
        symbol_name: row["SYMBOL_NAME"],
        display_name: row["DISPLAY_NAME"],
        series: row["SERIES"],
        lot_size: row["LOT_SIZE"].to_i.positive? ? row["LOT_SIZE"].to_i : nil,
        tick_size: row["TICK_SIZE"],
        asm_gsm_flag: row["ASM_GSM_FLAG"],
        asm_gsm_category: row["ASM_GSM_CATEGORY"],
        mtf_leverage: row["MTF_LEVERAGE"],
        exchange: row["EXCH_ID"],
        segment: row["SEGMENT"]
      )
    end
  end

  def self.import_derivatives(csv_data)
    puts "Importing Derivatives..."
    csv_data.each do |row|
      next unless row["STRIKE_PRICE"] && row["OPTION_TYPE"]

      puts "Importing Derivatives: #{row["DISPLAY_NAME"]} (#{row["INSTRUMENT"]}) #{row["STRIKE_PRICE"]} #{row["OPTION_TYPE"]}"
      expiry_date = parse_date(row["SM_EXPIRY_DATE"])
      next unless expiry_date && expiry_date >= Date.today # Only upcoming expiries

      instrument = Instrument.find_by(security_id: row["SECURITY_ID"], underlying_symbol: row["UNDERLYING_SYMBOL"])
      next unless instrument

      derivative = Derivative.find_or_initialize_by(
        instrument: instrument,
        strike_price: row["STRIKE_PRICE"],
        option_type: row["OPTION_TYPE"],
        expiry_date: expiry_date
      )
      derivative.update!(expiry_flag: row["EXPIRY_FLAG"])
    end
  end

  def self.import_margin_requirements(csv_data)
    puts "Importing Margin Requirements..."
    csv_data.each do |row|
      instrument = Instrument.find_by(security_id: row["SECURITY_ID"])
      next unless instrument

      margin = MarginRequirement.find_or_initialize_by(instrument: instrument)
      margin.update!(
        buy_co_min_margin_per: row["BUY_CO_MIN_MARGIN_PER"],
        sell_co_min_margin_per: row["SELL_CO_MIN_MARGIN_PER"],
        buy_bo_min_margin_per: row["BUY_BO_MIN_MARGIN_PER"],
        sell_bo_min_margin_per: row["SELL_BO_MIN_MARGIN_PER"],
        buy_co_sl_range_max_perc: row["BUY_CO_SL_RANGE_MAX_PERC"],
        sell_co_sl_range_max_perc: row["SELL_CO_SL_RANGE_MAX_PERC"],
        buy_co_sl_range_min_perc: row["BUY_CO_SL_RANGE_MIN_PERC"],
        sell_co_sl_range_min_perc: row["SELL_CO_SL_RANGE_MIN_PERC"],
        buy_bo_sl_range_max_perc: row["BUY_BO_SL_RANGE_MAX_PERC"],
        sell_bo_sl_range_max_perc: row["SELL_BO_SL_RANGE_MAX_PERC"],
        buy_bo_sl_range_min_perc: row["BUY_BO_SL_RANGE_MIN_PERC"],
        sell_bo_sl_min_range: row["SELL_BO_SL_MIN_RANGE"],
        buy_bo_profit_range_max_perc: row["BUY_BO_PROFIT_RANGE_MAX_PERC"],
        sell_bo_profit_range_max_perc: row["SELL_BO_PROFIT_RANGE_MAX_PERC"],
        buy_bo_profit_range_min_perc: row["BUY_BO_PROFIT_RANGE_MIN_PERC"],
        sell_bo_profit_range_min_perc: row["SELL_BO_PROFIT_RANGE_MIN_PERC"]
      )
    end
  end

  def self.import_order_features(csv_data)
    puts "Importing Order Features..."
    csv_data.each do |row|
      instrument = Instrument.find_by(security_id: row["SECURITY_ID"])
      next unless instrument

      feature = OrderFeature.find_or_initialize_by(instrument: instrument)
      feature.update!(
        bracket_flag: row["BRACKET_FLAG"],
        cover_flag: row["COVER_FLAG"],
        buy_sell_indicator: row["BUY_SELL_INDICATOR"]
      )
    end
  end

  def self.valid_instrument?(row)
    VALID_EXCHANGES.include?(row["EXCH_ID"]) && VALID_INSTRUMENTS.include?(row["INSTRUMENT"]) && row["LOT_SIZE"].to_i.positive?
  end

  def self.valid_buy_sell_indicator?(row)
    VALID_BUY_SELL_INDICATOR.include?(row["BUY_SELL_INDICATOR"])
  end

  def self.valid_expiry_date?(row)
    return true unless row["SM_EXPIRY_DATE"]

    expiry_date = parse_date(row["SM_EXPIRY_DATE"])
    expiry_date.nil? || expiry_date >= Date.today || expiry_date == parse_date("1979-12-31")
  end

  def self.parse_date(date_string)
    Date.parse(date_string) rescue nil
  end
end


# File: app/services/market_feed/adjustment_strategy.rb
module MarketFeed
  class AdjustmentStrategy
    def initialize(data)
      @data = data
    end

    def adjust
      # Example: Place limit orders or adjust stop-losses
      Rails.logger.info "Adjusting strategy for #{@data['SecurityId']}"
    end
  end
end


# File: app/services/market_feed/data_processor.rb
module MarketFeed
  class DataProcessor
    def initialize(data)
      @data = data
    end

    def process
      # Example logic: Parse and handle the market feed
      update_strategy if significant_movement?
    end

    private

    def significant_movement?
      # Implement logic to detect significant price changes
      @data["priceChange"] > 1.0
    end

    def update_strategy
      MarketFeed::AdjustmentStrategy.new(@data).adjust
    end
  end
end


# File: app/services/market_feed/handlers/full_packet_handler.rb
module MarketFeed
  module Handlers
    class FullPacketHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1("F"),
          last_traded_quantity: @io.read(2).unpack1("n"),
          last_traded_time: @io.read(4).unpack1("N"),
          average_trade_price: @io.read(4).unpack1("F"),
          volume: @io.read(4).unpack1("N"),
          open_interest: @io.read(4).unpack1("N"),
          day_high: @io.read(4).unpack1("F"),
          day_low: @io.read(4).unpack1("F"),
          market_depth: parse_market_depth
        }
      end

      private

      def parse_market_depth
        Array.new(5) do
          {
            bid_quantity: @io.read(4).unpack1("N"),
            ask_quantity: @io.read(4).unpack1("N"),
            bid_orders: @io.read(2).unpack1("n"),
            ask_orders: @io.read(2).unpack1("n"),
            bid_price: @io.read(4).unpack1("F"),
            ask_price: @io.read(4).unpack1("F")
          }
        end
      end
    end
  end
end


# File: app/services/market_feed/handlers/quote_handler.rb
module MarketFeed
  module Handlers
    class QuoteHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1("F"),
          last_traded_quantity: @io.read(2).unpack1("n"),
          last_traded_time: @io.read(4).unpack1("N"),
          average_trade_price: @io.read(4).unpack1("F"),
          volume: @io.read(4).unpack1("N"),
          total_sell_quantity: @io.read(4).unpack1("N"),
          total_buy_quantity: @io.read(4).unpack1("N"),
          day_open: @io.read(4).unpack1("F"),
          day_high: @io.read(4).unpack1("F"),
          day_low: @io.read(4).unpack1("F")
        }
      end
    end
  end
end


# File: app/services/market_feed/handlers/ticker_handler.rb
module MarketFeed
  module Handlers
    class TickerHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1("F"), # Float
          last_traded_time: @io.read(4).unpack1("N")   # Unsigned 32-bit
        }
      end
    end
  end
end


# File: app/services/market_feed/packet_parser.rb
module MarketFeed
  class PacketParser
    def self.parse(binary_data)
      # Convert binary data into a readable format
      io = StringIO.new(binary_data)

      # Parse the Response Header
      response_code = io.read(1).unpack1("C") # Unsigned char
      message_length = io.read(2).unpack1("n") # Unsigned 16-bit (big-endian)
      exchange_segment = io.read(1).unpack1("C") # Unsigned char
      security_id = io.read(4).unpack1("N") # Unsigned 32-bit (big-endian)

      # Fetch Payload Handler
      handler = handler_for_response_code(response_code)
      payload = handler ? handler.new(io).parse_payload : nil

      {
        response_code: response_code,
        message_length: message_length,
        exchange_segment: exchange_segment,
        security_id: security_id,
        payload: payload
      }
    end

    def self.handler_for_response_code(response_code)
      case response_code
      when 2
        Handlers::TickerHandler
      when 4
        Handlers::QuoteHandler
      when 8
        Handlers::FullPacketHandler
      else
        nil # Unknown handler
      end
    end
  end
end


# File: app/services/market_feed_subscription_service.rb
class MarketFeedSubscriptionService
  def self.subscribe_to_equities
    instruments = Instrument.equities.limit(1000).pluck(:exchange_segment, :security_id)
    formatted_instruments = instruments.map do |segment, id|
      { exchange_segment: segment, security_id: id }
    end

    live_feed = LiveMarketFeed.new
    live_feed.subscribe_to_instruments(formatted_instruments)
  end
end


# File: app/services/option/chain_analyzer.rb
module Option
  class ChainAnalyzer
    def initialize(options_chain)
      @options_chain = options_chain.with_indifferent_access
    end

    def analyze
      {
        max_pain: calculate_max_pain,
        oi_support_resistance: analyze_oi_support_resistance,
        greeks_summary: analyze_greeks,
        price_action_trends: analyze_price_action
      }
    end

    private

    def calculate_max_pain
      strikes = @options_chain.dig(:oc).keys
      strikes.map do |strike|
        oi_call = @options_chain.dig(:oc, strike, "ce", :open_interest).to_i
        oi_put = @options_chain.dig(:oc, strike, "pe", :open_interest).to_i
        [ strike, oi_call + oi_put ]
      end.min_by { |_strike, combined_oi| combined_oi }&.first
    end

    def analyze_oi_support_resistance
      calls = @options_chain.dig(:oc).filter_map do |strike, data|
        { strike: strike.to_f, oi: data.dig("ce", :open_interest).to_i } if data["ce"]
      end
      pe = @options_chain.dig(:oc).filter_map do |strike, data|
        { strike: strike.to_f, oi: data.dig("pe", :open_interest).to_i } if data["pe"]
      end

      {
        resistance: calls.max_by { |c| c[:oi] }&.dig(:strike),
        support: pe.max_by { |p| p[:oi] }&.dig(:strike)
      }
    end

    def analyze_greeks
      greeks = %w[delta gamma theta vega].each_with_object({}) do |greek, summary|
        values = @options_chain.dig(:oc).values.flat_map do |data|
          [ data.dig("ce", greek), data.dig("pe", greek) ].compact
        end
        summary[:"#{greek}_avg"] = values.sum / values.size if values.any?
      end

      greeks
    end

    def analyze_price_action
      prices = @options_chain.dig(:prices) || [] # Assume price data is available in the options chain
      volumes = @options_chain.dig(:volumes) || [] # Assume volume data is available

      return { bullish: false, bearish: false, neutral: true } if prices.empty? || prices.size < 5

      # Calculate Moving Averages
      short_term_ma = moving_average(prices, 5) # 5-period MA
      long_term_ma = moving_average(prices, 20) # 20-period MA

      # Determine Trends
      bullish = short_term_ma.last > long_term_ma.last && increasing(prices) && increasing(volumes)
      bearish = short_term_ma.last < long_term_ma.last && decreasing(prices) && decreasing(volumes)
      neutral = !bullish && !bearish

      { bullish: bullish, bearish: bearish, neutral: neutral }
    end

    private

    def moving_average(data, period)
      return [] if data.size < period
      data.each_cons(period).map { |sub_array| sub_array.sum / period.to_f }
    end

    def increasing(data)
      data.each_cons(2).all? { |a, b| b >= a }
    end

    def decreasing(data)
      data.each_cons(2).all? { |a, b| b <= a }
    end
  end
end


# File: app/services/option/strategy_example_updater.rb
module Option
  class StrategyExampleUpdater
    def self.update_examples(option_chain, params)
      Strategy.all.each do |strategy|
        suggester = StrategySuggester.new(option_chain, params)
        example = suggester.generate_example(strategy.name)
        strategy.update(example: example) if example.is_a?(String)
      end
    end
  end
end


# File: app/services/option/strategy_suggester.rb
module Option
  class StrategySuggester
    def initialize(option_chain, params)
      @option_chain = option_chain.with_indifferent_access
      @params = params
      @current_price = @option_chain.dig(:last_price) || 0
    end

    def suggest(criteria = {})

      analysis = criteria[:analysis]
      strategies = Strategy.all

      strategies = filter_by_outlook(strategies, criteria[:outlook])
      strategies = filter_by_volatility(strategies, criteria[:volatility])
      strategies = filter_by_risk(strategies, criteria[:risk])
      strategies = filter_by_option_preference(strategies, criteria[:option_preference])

      # Map filtered strategies with generated examples
      strategies.map do |strategy|
        strategy.as_json.merge(
          example: generate_example(strategy.name)
        )
      end
    end

    def generate_example(name)
      case name
      when "Bull Call Spread"
        call_buy = best_option("ce")
        call_sell = far_option("ce", "OTM")
        if call_buy && call_sell
          format_example("Buy #{call_buy[:symbol]} and Sell #{call_sell[:symbol]} @ ₹#{call_buy[:last_price]} - ₹#{call_sell[:last_price]}")
        end
      when "Bear Put Spread"
        put_buy = best_option("pe")
        put_sell = far_option("pe", "OTM")
        if put_buy && put_sell
          format_example("Buy #{put_buy[:symbol]} and Sell #{put_sell[:symbol]} @ ₹#{put_buy[:last_price]} - ₹#{put_sell[:last_price]}")
        end
      when "Short Straddle"
        call_option = best_option("ce")
        put_option = best_option("pe")
        if call_option && put_option
          format_example("Sell #{call_option[:symbol]} and Sell #{put_option[:symbol]} @ ₹#{call_option[:last_price]} + ₹#{put_option[:last_price]}")
        end
      when "Short Strangle"
        call_option = far_option("ce", "OTM")
        put_option = far_option("pe", "OTM")
        if call_option && put_option
          format_example("Sell #{call_option[:symbol]} and Sell #{put_option[:symbol]} @ ₹#{call_option[:last_price]} + ₹#{put_option[:last_price]}")
        end
      when "Protective Long Put"
        put_option = best_option("pe")
        if put_option
          format_example("Buy #{put_option[:symbol]} to hedge a long position @ ₹#{put_option[:last_price]}")
        end
      when "Iron Butterfly"
        call_sell = best_option("ce")
        put_sell = best_option("pe")
        call_buy = far_option("ce", "OTM")
        put_buy = far_option("pe", "OTM")
        if call_sell && put_sell && call_buy && put_buy
          format_example("Sell #{call_sell[:symbol]}, Sell #{put_sell[:symbol]}, Buy #{call_buy[:symbol]}, Buy #{put_buy[:symbol]}")
        end
      when "Iron Condor"
        call_sell = far_option("ce", "OTM")
        put_sell = far_option("pe", "OTM")
        call_buy = far_option("ce", "OTM")
        put_buy = far_option("pe", "OTM")
        if call_sell && put_sell && call_buy && put_buy
          format_example("Sell #{call_sell[:symbol]}, Sell #{put_sell[:symbol]}, Buy #{call_buy[:symbol]}, Buy #{put_buy[:symbol]} @ ₹#{call_sell[:last_price]} + ₹#{put_sell[:last_price]} - ₹#{call_buy[:last_price]} - ₹#{put_buy[:last_price]}")
        end
      when "Long Calendar Spread"
        long_option = best_option("ce")
        short_option = best_option("ce")
        if long_option && short_option
          format_example("Buy #{long_option[:symbol]} (Jan expiry) and Sell #{short_option[:symbol]} (Dec expiry) @ ₹#{long_option[:last_price]} - ₹#{short_option[:last_price]}")
        end
      else
        strategy = Strategy.find_by(name: name)
        strategy&.example || { note: "No dynamic example available for this strategy." }
      end
    end

    private

    def filter_by_outlook(strategies, outlook)
      return strategies unless outlook

      case outlook
      when "bullish"
        strategies.where(name: [ "Long Call", "Bull Call Spread", "Long Ratio Backspread", "Protective Long Put" ])
      when "bearish"
        strategies.where(name: [ "Long Put", "Bear Put Spread", "Short Straddle", "Short Strangle" ])
      else
        strategies
      end
    end

    def filter_by_volatility(strategies, volatility)
      return strategies unless volatility

      case volatility
      when "high"
        strategies.where(name: [ "Long Straddle", "Long Strangle", "Iron Butterfly", "Long Vega (Volatility Play)" ])
      when "low"
        strategies.where(name: [ "Short Straddle", "Short Strangle", "Iron Condor", "Iron Butterfly" ])
      else
        strategies
      end
    end

    def filter_by_risk(strategies, risk)
      return strategies unless risk

      case risk
      when "low"
        strategies.where(name: [ "Iron Condor", "Iron Butterfly", "Protective Long Put" ])
      when "moderate"
        strategies.where(name: [ "Bull Call Spread", "Bear Put Spread", "Long Calendar Spread", "Long Ratio Backspread" ])
      when "high"
        strategies.where(name: [ "Long Call", "Long Put", "Long Straddle", "Long Strangle" ])
      else
        strategies
      end
    end

    def filter_by_option_preference(strategies, preference)
      return strategies unless preference

      case preference
      when "buy"
        strategies.where(name: [ "Long Call", "Long Put", "Long Straddle", "Long Strangle", "Bull Call Spread", "Bear Put Spread", "Protective Long Put", "Long Vega (Volatility Play)" ])
      when "sell"
        strategies.where(name: [ "Short Straddle", "Short Strangle", "Iron Condor", "Iron Butterfly" ])
      else
        strategies
      end
    end

    def best_option(type)
      options = @option_chain.dig(:oc).select { |strike, data| data[type].present? }
      return nil if options.empty?

      options.map do |strike, data|
        {
          strike_price: strike.to_f,
          last_price: data[type][:last_price],
          symbol: "#{@params[:index_symbol]}-#{strike.to_i}-#{type.upcase}"
        }
      end.min_by { |o| (o[:strike_price] - @current_price).abs }
    end

    def far_option(type, position)
      options = @option_chain.dig(:oc).select { |strike, data| data[type].present? }
      return nil if options.empty?

      mapped_options = options.map do |strike, data|
        {
          strike_price: strike.to_f,
          last_price: data[type][:last_price],
          symbol: "#{@params[:index_symbol]}-#{strike.to_i}-#{type.upcase}"
        }
      end

      case position
      when "OTM"
        mapped_options.select { |o| o[:strike_price] > @current_price }.min_by { |o| o[:strike_price] - @current_price }
      when "ITM"
        mapped_options.select { |o| o[:strike_price] < @current_price }.max_by { |o| o[:strike_price] }
      else
        nil
      end
    end

    def format_example(action)
      {
        action: action,
        max_loss: "Premium Paid",
        max_profit: "Unlimited (in most cases)",
        note: "Example generated dynamically based on the current option chain."
      }
    end
  end
end


# File: app/services/option/suggest_strategy_service.rb
module Option
  class SuggestStrategyService
    def self.call(index_symbol:, expiry_date:, params:)
      instrument = Instrument.segment_index.find_by(underlying_symbol: index_symbol)
      raise "Invalid index symbol. #{index_symbol}" if instrument.nil?
      expiry_date = instrument.expiry_list.find { |e| e["Expiry"] == expiry_date } || instrument.expiry_list.first

      option_chain = instrument.fetch_option_chain(expiry_date)


      analysis = ChainAnalyzer.new(option_chain).analyze
      suggester = StrategySuggester.new(option_chain, params)

      suggester.suggest(
        analysis: analysis,
        option_preference: params[:option_preference] || "both",
        outlook: params[:outlook],
        volatility: params[:volatility],
        risk: params[:risk]
      )
    end
  end
end


# File: app/services/order_management/order_processor.rb


# File: app/services/orders/strategies/base_strategy.rb
module Orders
  module Strategies
    class BaseStrategy
      attr_reader :alert, :instrument, :security_symbol, :exchange

      def initialize(alert)
        @alert = alert
        @security_symbol = alert[:ticker]
        pp alert[:exchange]
        @exchange = Exchange.find_by(exch_id: alert[:exchange])
      end

      def execute
        raise NotImplementedError, "#{self.class} must implement #execute"
      end

      private

      # Fetch the instrument record
      def instrument
        @instrument ||= Instrument.find_by!(
          exchange: exchange,
          underlying_symbol: security_symbol,
          instrument_type: alert[:instrument_type] == "stock" ? "ES" : "INDEX"
        )
      rescue ActiveRecord::RecordNotFound
        raise "Instrument not found for #{security_symbol} in #{exchange}"
      end

      # Fetch available funds
      def fetch_funds
        Dhanhq::API::Funds.balance["availabelBalance"].to_f
      end

      # Prepare common order parameters
      def dhan_order_params
        {
          transactionType: alert[:action].upcase,
          orderType: Dhanhq::Constants::MARKET,
          productType: default_product_type,
          validity: Dhanhq::Constants::DAY,
          securityId: instrument.security_id,
          exchangeSegment: map_exchange_segment(instrument.exchange_segment_code),
          quantity: calculate_quantity(alert[:current_price])
        }
      end

      # Map exchange segments dynamically
      def map_exchange_segment(exchange)
        Dhanhq::Constants::EXCHANGE_SEGMENTS.find { |seg| seg.include?(exchange) } ||
          raise("Unsupported exchange: #{exchange}")
      end

      def calculate_quantity(price)
        utilized_funds = fetch_funds * funds_utilization * leverage_factor

        lot_size = instrument.lot_size || 1
        max_quantity = (utilized_funds / price).floor

        quantity = (max_quantity / lot_size) * lot_size
        [ quantity, lot_size ].max
      end

      def leverage_factor
        1.0 # Default leverage is 1x
      end

      def funds_utilization
        0.3 # 30% utilization of funds
      end

      # Default product type (can be overridden by subclasses)
      def default_product_type
        Dhanhq::Constants::INTRA # Default to intraday
      end

      # Place an order using Dhan API
      def place_order(params)
        pp params
        # Dhanhq::API::Orders.place(params)
      rescue StandardError => e
        raise "Failed to place order: #{e.message}"
      end
    end
  end
end


# File: app/services/orders/strategies/intraday_futures_strategy.rb
module Orders
  module Strategies
    class IntradayFuturesStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params.merge(productType: Dhanhq::Constants::INTRA))
      end
    end
  end
end


# File: app/services/orders/strategies/intraday_index_strategy.rb
module Orders
  module Strategies
    class IntradayIndexStrategy < IntradayOptionsStrategy
      private

      def determine_option_type(action)
        # Index uses CALL/PUT
        super
      end
    end
  end
end


# File: app/services/orders/strategies/intraday_options_strategy.rb
module Orders
  module Strategies
    class IntradayOptionsStrategy < BaseStrategy
      def execute
        strike_price = calculate_strike_price(alert[:current_price])
        option_type = determine_option_type(alert[:action].upcase)

        place_order(
          dhan_order_params.merge(
            productType: Dhanhq::Constants::INTRA,
            strikePrice: strike_price,
            optionType: option_type,
            expiryDate: nearest_expiry_date
          )
        )
      end

      private

      def calculate_strike_price(price)
        step = instrument.tick_size || 50
        (price / step).round * step
      end

      def determine_option_type(action)
        case action
        when Dhanhq::Constants::BUY then "CE" # Call Option
        when Dhanhq::Constants::SELL then "PE" # Put Option
        else
          raise "Invalid action: #{action}"
        end
      end

      def nearest_expiry_date
        Derivative.where(instrument: instrument)
                  .where("expiry_date >= ?", Date.today)
                  .order(:expiry_date)
                  .limit(1)
                  .pluck(:expiry_date)
                  .first
      end
    end
  end
end


# File: app/services/orders/strategies/intraday_stock_strategy.rb
module Orders
  module Strategies
    class IntradayStockStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params)
      end

      private

      def leverage_factor
        mis_detail = instrument.mis_detail
        mis_detail&.mis_leverage.to_i || 1 # Default to 1x if no MIS details found
      end

      def calculate_quantity(price)
        available_funds = fetch_funds * 0.3 # Use 30% of funds
        max_quantity = (available_funds / price).floor
        lot_size = instrument.lot_size || 1

        # Adjust quantity based on lot size
        quantity = (max_quantity / lot_size) * lot_size
        [ quantity, lot_size ].max
      end

      def default_product_type
        Dhanhq::Constants::INTRA # Override default to intraday
      end
    end
  end
end


# File: app/services/orders/strategies/options_strategy.rb
module Orders
  module Strategies
    class OptionsStrategy < BaseStrategy
      def execute
        strike_price = calculate_strike_price(alert[:current_price])
        option_type = determine_option_type(alert[:action].upcase)
        raise "Lot size not found for #{alert[:ticker]}" unless instrument.lot_size

        place_order(
          dhan_order_params.merge(
            productType: default_product_type,
            strikePrice: calculate_strike_price(alert[:current_price]),
            optionType: determine_option_type(alert[:action].upcase),
            expiryDate: nearest_expiry_date
          )
        )
      end

      private

      def default_product_type
        Dhanhq::Constants::CNC # Options are typically delivery
      end

      def calculate_strike_price(price)
        step = instrument.tick_size || 50 # Default to 50 if tick size is missing
        (price / step).round * step
      end

      def determine_option_type(action)
        case action
        when Dhanhq::Constants::BUY then "CE" # Call
        when Dhanhq::Constants::SELL then "PE" # Put
        else
          raise "Invalid action for options: #{action}"
        end
      end

      def nearest_expiry_date
        Instrument.where(
          underlying_symbol: instrument.underlying_symbol,
          expiry_flag: instrument.expiry_flag
        ).where("sm_expiry_date >= ?", Date.today)
         .order(:sm_expiry_date)
         .limit(1)
         .pluck(:sm_expiry_date)
         .first
      end
    end
  end
end


# File: app/services/orders/strategies/stock_order_strategy.rb
module Orders
  module Strategies
    class StockOrderStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params)
      end
    end
  end
end


# File: app/services/orders/strategies/swing_futures_strategy.rb
module Orders
  module Strategies
    class SwingFuturesStrategy < IntradayFuturesStrategy
      private

      def default_product_type
        Dhanhq::Constants::CNC # Swing Trading Futures
      end
    end
  end
end


# File: app/services/orders/strategies/swing_index_strategy.rb
module Orders
  module Strategies
    class SwingIndexStrategy < SwingOptionsStrategy
    end
  end
end


# File: app/services/orders/strategies/swing_options_strategy.rb
module Orders
  module Strategies
    class SwingOptionsStrategy < IntradayOptionsStrategy
      private

      def default_product_type
        Dhanhq::Constants::CNC # Delivery-based options
      end
    end
  end
end


# File: app/services/orders/strategies/swing_stock_strategy.rb
module Orders
  module Strategies
    class SwingStockStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params.merge(productType: Dhanhq::Constants::CNC))
      end

      private

      def default_product_type
        Dhanhq::Constants::CNC # Delivery-based product
      end
    end
  end
end


# File: app/services/orders/strategies/unified_options_strategy.rb
module Orders
  module Strategies
    class UnifiedOptionsStrategy < BaseStrategy
      def execute
        place_order(
          dhan_order_params.merge(
            strikePrice: calculate_strike_price(alert[:current_price]),
            quantity: calculate_quantity(alert[:current_price])
          )
        )
      end

      private

      def calculate_strike_price(price)
        step = instrument.tick_size || 50
        (price / step).round * step
      end
    end
  end
end


# File: app/services/order_service.rb
# app/services/order_service.rb
class OrderService
  def self.place_order(ticker:, action:, quantity:, price:, security_id:, trailing_stop_loss:)
    response = Dhanhq::API::Orders.place(
      transactionType: action.upcase,
      exchangeSegment: "NSE_EQ",
      productType: "CNC",
      orderType: "MARKET",
      securityId: security_id,
      quantity: quantity,
      price: price
    )

    Order.create(
      ticker: ticker,
      action: action,
      quantity: quantity,
      price: price,
      dhan_order_id: response["orderId"],
      dhan_status: response["orderStatus"],
      security_id: security_id,
      stop_loss_price: calculate_stop_loss(price, action, trailing_stop_loss),
      take_profit_price: calculate_take_profit(price)
    )
  end

  def self.calculate_stop_loss(price, action, trailing_stop_loss)
    action == "BUY" ? price - trailing_stop_loss : price + trailing_stop_loss
  end

  def self.calculate_take_profit(price)
    price * 1.02 # 1:2 profit-loss ratio
  end
end


# File: app/services/parsers/live_order_parser.rb
# app/services/parsers/live_order_parser.rb
module Parsers
  class LiveOrderParser
    REQUIRED_FIELDS = %w[
      Exchange Segment Source SecurityId ClientId ExchOrderNo OrderNo Product
      TxnType OrderType Validity RemainingQuantity Quantity TradedQty Price
      TriggerPrice TradedPrice AvgTradedPrice OrderDateTime ExchOrderTime
      LastUpdatedTime Remarks Status Symbol DisplayName Isin
    ].freeze

    def initialize(raw_data)
      @raw_data = raw_data
      @parsed_data = {}
    end

    def parse
      extract_data
      validate_data
      @parsed_data
    rescue StandardError => e
      Rails.logger.error("LiveOrderParser failed: #{e.message}")
      nil
    end

    private

    attr_reader :raw_data

    def extract_data
      @parsed_data = raw_data["Data"].slice(*REQUIRED_FIELDS)
    end

    def validate_data
      missing_fields = REQUIRED_FIELDS - @parsed_data.keys
      raise "Missing required fields: #{missing_fields.join(', ')}" unless missing_fields.empty?
    end
  end
end


# File: app/services/strategy_factory.rb
class StrategyFactory
  STRATEGY_MAP = {
    "Supertrend Strategy + Indicator" => Strategies::SupertrendStrategy,
    "VWAP Strategy" => Strategies::VWAPStrategy
  }.freeze

  def self.build(strategy_name)
    STRATEGY_MAP.fetch(strategy_name) { raise NotImplementedError, "Unknown strategy: #{strategy_name}" }.new
  end
end


# File: app/services/websocket_handlers/live_market_feed.rb
require "faye/websocket"
require "eventmachine"
require "json"

class LiveMarketFeed
  MAX_INSTRUMENTS_PER_BATCH = 100

  def initialize
    @url = build_url
    @subscribed_instruments = []
  end

  def connect
    EM.run do
      @ws = Faye::WebSocket::Client.new(@url)

      @ws.on(:open) do |_event|
        Rails.logger.info "[LiveMarketFeed] WebSocket connection established."
      end

      @ws.on(:message) do |event|
        handle_message(event.data)
      end

      @ws.on(:close) do |event|
        Rails.logger.warn "[LiveMarketFeed] WebSocket connection closed: Code=#{event.code}, Reason=#{event.reason}"
        EM.stop
      end

      @ws.on(:error) do |event|
        Rails.logger.error "[LiveMarketFeed] WebSocket encountered an error: #{event.message}"
      end
    end
  end

  def subscribe_to_instruments(instruments)
    instruments.each_slice(MAX_INSTRUMENTS_PER_BATCH) do |batch|
      subscription_message = {
        RequestCode: 15,
        InstrumentCount: batch.size,
        InstrumentList: batch.map do |inst|
          { ExchangeSegment: inst[:exchange_segment], SecurityId: inst[:security_id] }
        end
      }

      send_message(subscription_message)
    end

    @subscribed_instruments.concat(instruments)
    Rails.logger.info "[LiveMarketFeed] Subscribed to #{instruments.size} instruments."
  end

  def unsubscribe_all
    send_message({ RequestCode: 16 })
    @subscribed_instruments.clear
    Rails.logger.info "[LiveMarketFeed] Unsubscribed from all instruments."
  end

  private

  def build_url
    token = ENV.fetch("DHAN_ACCESS_TOKEN")
    client_id = ENV.fetch("DHAN_CLIENT_ID")
    "wss://api-feed.dhan.co?version=2&token=#{token}&clientId=#{client_id}&authType=2"
  end

  def send_message(message)
    if @ws
      @ws.send(message.to_json)
      Rails.logger.info "[LiveMarketFeed] Sent message: #{message}"
    else
      Rails.logger.error "[LiveMarketFeed] WebSocket connection not established. Cannot send message."
    end
  end

  def handle_message(data)
    begin
      # Market feed messages are in binary and need to be parsed
      parsed_data = MarketFeed::PacketParser.parse(data)
      MarketFeed::DataProcessor.new(parsed_data).process
    rescue JSON::ParserError => e
      Rails.logger.error "[LiveMarketFeed] Failed to parse message: #{e.message}. Raw data: #{data}"
    rescue StandardError => e
      Rails.logger.error "[LiveMarketFeed] Error processing message: #{e.message}"
    end
  end
end


# File: app/services/websocket_handlers/live_order_update.rb
require "faye/websocket"
require "eventmachine"
require "json"

class LiveOrderUpdate
  def initialize
    @url = "wss://api-order-update.dhan.co"
    @auth_message = {
      LoginReq: {
        MsgCode: 42,
        ClientId: ENV.fetch("DHAN_CLIENT_ID"),
        Token: ENV.fetch("DHAN_ACCESS_TOKEN")
      },
      UserType: "SELF"
    }
  end

  def connect
    EM.run do
      @ws = Faye::WebSocket::Client.new(@url)

      @ws.on(:open) do |_event|
        authenticate
        Rails.logger.info "[LiveOrderUpdate] WebSocket connection established."
      end

      @ws.on(:message) do |event|
        handle_message(event.data)
      end

      @ws.on(:close) do |event|
        Rails.logger.warn "[LiveOrderUpdate] WebSocket connection closed: Code=#{event.code}, Reason=#{event.reason}"
        EM.stop
      end

      @ws.on(:error) do |event|
        Rails.logger.error "[LiveOrderUpdate] WebSocket encountered an error: #{event.message}"
      end
    end
  end

  private

  def authenticate
    if @ws
      @ws.send(@auth_message.to_json)
      Rails.logger.info "[LiveOrderUpdate] Authentication message sent."
    else
      Rails.logger.error "[LiveOrderUpdate] WebSocket connection not established. Cannot authenticate."
    end
  end

  def handle_message(data)
    begin
      parsed_data = JSON.parse(data)

      # Ensure the message type is `order_alert`
      if parsed_data["Type"] == "order_alert"
        process_order_update(parsed_data["Data"])
      else
        Rails.logger.info "[LiveOrderUpdate] Unhandled message type: #{parsed_data['Type']}"
      end

    rescue JSON::ParserError => e
      Rails.logger.error "[LiveOrderUpdate] JSON parsing failed: #{e.message}. Raw data: #{data}"
    rescue StandardError => e
      Rails.logger.error "[LiveOrderUpdate] Error processing message: #{e.message}. Data: #{data}"
    end
  end

  def process_order_update(order_data)
    # Validate presence of required fields
    required_fields = %w[OrderNo Status Symbol Price TradedQty]
    missing_fields = required_fields - order_data.keys

    if missing_fields.any?
      Rails.logger.warn "[LiveOrderUpdate] Missing required fields: #{missing_fields.join(', ')}. Data: #{order_data}"
      return
    end

    # Example: Update the order in the database
    order = Order.find_by(dhan_order_id: order_data["OrderNo"])
    if order
      order.update(
        dhan_status: order_data["Status"],
        traded_price: order_data["TradedPrice"],
        remaining_quantity: order_data["RemainingQuantity"],
        traded_quantity: order_data["TradedQty"],
        last_updated_time: order_data["LastUpdatedTime"]
      )
      Rails.logger.info "[LiveOrderUpdate] Order updated successfully: OrderNo=#{order_data['OrderNo']}"
    else
      Rails.logger.warn "[LiveOrderUpdate] Order not found: OrderNo=#{order_data['OrderNo']}"
    end
  end
end


# File: app/validators/alert_validator.rb
class AlertValidator
  include ActiveModel::Model

  attr_accessor :ticker, :instrument_type, :action, :order_type, :current_position,
                :previous_position, :current_price, :high, :low, :volume, :time,
                :stop_loss, :take_profit, :trailing_stop_loss, :strategy_name, :strategy_id

  validates :ticker, :instrument_type, :action, :order_type, :strategy_name, :strategy_id, presence: true
  validates :instrument_type, inclusion: { in: %w[stock index] }
  validates :action, inclusion: { in: %w[buy sell] }
  validates :order_type, inclusion: { in: %w[market limit stop] }
  validates :current_price, :stop_loss, :take_profit, numericality: { greater_than: 0 }
  validates :volume, numericality: { only_integer: true, greater_than_or_equal_to: 0 }
  validates :time, presence: true

  def initialize(params = {})
    super(params.permit(:ticker, :instrument_type, :action, :order_type, :current_position,
                        :previous_position, :current_price, :high, :low, :volume, :time,
                        :stop_loss, :take_profit, :trailing_stop_loss, :strategy_name, :strategy_id))
  end
end


# File: app/views/layouts/mailer.html.erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>


# File: app/views/layouts/mailer.text.erb
<%= yield %>


# File: lib/tasks/csv_import.rake
namespace :csv do
  desc "Import instruments from CSV"
  task import: :environment do
    begin
      puts "Starting CSV import process..."

      # Dynamically download and import the CSV
      CsvImporter.import

      puts "CSV import completed successfully!"
    rescue StandardError => e
      puts "An error occurred during the import: #{e.message}"
      puts e.backtrace.join("\n")
    end
  end
end


# File: lib/tasks/import_mis_data.rake
namespace :data do
  desc "Import MIS Details from CSV"
  task import_mis: :environment do
    require "csv"

    # Define the path to the CSV file
    file_path = Rails.root.join("mis_data.csv")

    # Check if the file exists
    unless File.exist?(file_path)
      puts "File not found at #{file_path}. Please make sure the file is present in the root folder."
      exit
    end

    begin
      # Start processing the CSV file
      puts "Starting MIS data import from #{file_path}..."

      CSV.foreach(file_path, headers: true) do |row|
        # Skip rows with missing critical data
        if row["Symbol / Scrip Name"].blank?

          puts "Skipping row due to missing critical data: #{row.to_h}"
          Rails.logger.warn "Skipping row due to missing critical data: #{row.to_h}"
          next
        end

        # Fetch the associated instruments
        instruments = Instrument.joins(:exchange, :segment)
                                 .where(underlying_symbol: row["Symbol / Scrip Name"], isin: row["ISIN"])

        if instruments.empty?
          Rails.logger.warn "No matching instruments found for Symbol: #{row['Symbol / Scrip Name']}, Exchange: #{row['Exchange ID']}, Segment: #{row['Segment Code']}"
          next
        end

        instruments.each do |instrument|
          # Update or create MIS details for the instrument
          mis_detail = MisDetail.find_or_initialize_by(instrument: instrument)
          mis_detail.assign_attributes(
            isin: row["ISIN"],
            mis_leverage: row["MIS(Intraday)"]&.delete("x")&.to_i,
            bo_leverage: row["BO(Bracket)"]&.delete("x")&.to_i,
            co_leverage: row["CO(Cover)"]&.delete("x")&.to_i
          )

          if mis_detail.save
            puts "Updated MIS details for Instrument: #{instrument.symbol_name} (#{instrument.security_id})"
          else
            Rails.logger.error "Failed to save MIS details for Instrument: #{instrument.symbol_name}. Errors: #{mis_detail.errors.full_messages.join(', ')}"
          end
        end
      end

      puts "MIS data import completed successfully!"
    rescue StandardError => e
      Rails.logger.error "An error occurred during MIS data import: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
      puts "MIS data import failed. Check the logs for details."
    end
  end
end


# File: lib/tasks/strategy_example_updater.rake
namespace :strategy do
  desc "Update strategy examples with current option chain data"
  task update_examples: :environment do
    option_chain = {} # Fetch or mock the option chain data
    params = { index_symbol: "Nifty" }

    Option::StrategyExampleUpdater.update_examples(option_chain, params)
    puts "Strategy examples updated successfully."
  end
end


# File: config/initializers/cors.rb
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins "*" # Update '*' with specific domains for security, e.g., 'http://localhost:3000'

    resource "*",
             headers: :any,
             methods: [ :get, :post, :put, :patch, :delete, :options, :head ]
  end
end


# File: config/initializers/dhanhq_mappings.rb
module DhanhqMappings
  EXCHANGES = {
    "NSE" => "National Stock Exchange",
    "BSE" => "Bombay Stock Exchange",
    "MCX" => "Multi Commodity Exchange"
  }.freeze

  # SEGMENTS = {
  #   "IDX_I" => "Index",
  #   "NSE_EQ" => "Equity Cash",
  #   "NSE_FNO" => "Futures & Options",
  #   "NSE_CURRENCY" => "Currency",
  #   "BSE_EQ" => "Equity Cash",
  #   "MCX_COMM" => "Commodity"
  # }.freeze

  SEGMENTS = {
    I: "Index",
    E: "Equity",
    D: "Derivatives",
    C: "Currency",
    M: "Commodity"
  }.freeze

  PRODUCT_TYPES = {
    "CNC" => "Cash & Carry",
    "INTRADAY" => "Intraday",
    "MARGIN" => "Carry Forward",
    "CO" => "Cover Order",
    "BO" => "Bracket Order"
  }.freeze

  ORDER_STATUSES = {
    "TRANSIT" => "Did not reach the exchange server",
    "PENDING" => "Awaiting execution",
    "REJECTED" => "Rejected by broker/exchange",
    "CANCELLED" => "Cancelled by user",
    "TRADED" => "Executed successfully",
    "EXPIRED" => "Validity expired"
  }.freeze

  INSTRUMENT_TYPES = {
    "INDEX" => "Index",
    "FUTIDX" => "Futures of Index",
    "OPTIDX" => "Options of Index",
    "EQUITY" => "Equity",
    "FUTSTK" => "Futures of Stock",
    "OPTSTK" => "Options of Stock"
  }.freeze

  EXPIRY_FLAGS = {
    "M" => "Monthly Expiry",
    "W" => "Weekly Expiry"
  }.freeze
end


# File: config/initializers/dhanhq.rb
require "dhanhq"

Dhanhq.configure do |config|
  config.client_id = ENV["DHAN_CLIENT_ID"]
  config.access_token = ENV["DHAN_ACCESS_TOKEN"]
end


# File: config/initializers/filter_parameter_logging.rb
# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += [
  :passw, :email, :secret, :token, :_key, :crypt, :salt, :certificate, :otp, :ssn, :cvv, :cvc
]


# File: config/initializers/inflections.rb
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end


# File: config/initializers/websockets.rb
Thread.new do
  # Start Live Market Feed WebSocket
  begin
    market_feed = LiveMarketFeed.new
    market_feed.connect
  rescue StandardError => e
    Rails.logger.error "[WebSocket] Error starting LiveMarketFeed: #{e.message}"
  end

  # Start Live Order Update WebSocket
  begin
    order_update = LiveOrderUpdate.new
    order_update.connect
  rescue StandardError => e
    Rails.logger.error "[WebSocket] Error starting LiveOrderUpdate: #{e.message}"
  end
end


