# File: app/controllers/application_controller.rb
# frozen_string_literal: true

class ApplicationController < ActionController::API
  rescue_from StandardError, with: :handle_internal_error

  private

  def handle_internal_error(exception)
    ErrorLogger.log_error('Internal server error', exception)
    render json: { error: 'Internal server error' }, status: :internal_server_error
  end
end


# File: app/controllers/funds_controller.rb
# frozen_string_literal: true

class FundsController < ApplicationController
  def index
    funds = FundsService.fetch_funds
    render json: funds.except(:dhanClientId)
  rescue StandardError => e
    render json: ErrorHandler.handle_error(
      context: 'FundsController#index',
      exception: e
    ), status: :unprocessable_entity
  end
end


# File: app/controllers/instruments_controller.rb
# frozen_string_literal: true

class InstrumentsController < ApplicationController
  def index
    # Initialize the Ransack search object
    q = Instrument.ransack(params[:q])

    # Perform search and paginate results
    instruments = q.result.page(params[:page]).per(params[:per_page] || 20)

    render json: {
      instruments: instruments, meta: {
        current_page: instruments.current_page,
        total_pages: instruments.total_pages,
        total_count: instruments.total_count
      }
    }
  end

  def show
    instrument = Instrument.find(params[:id])
    render json: instrument
  end

  private

  def instrument_params
    params.require(:instrument).permit(:id, :symbol_name, :display_name, :exchange, :segment)
  end
end


# File: app/controllers/mis_details_controller.rb
# frozen_string_literal: true

class MisDetailsController < ApplicationController
  def index
    # Use Ransack for searching
    search = MisDetail.includes(:instrument).ransack(params[:q])
    mis_details = search.result.page(params[:page]).per(params[:per_page] || 10)

    # Prepare the response with associated instrument details
    render json: {
      mis_details: mis_details.as_json(include: {
                                         instrument: {
                                           only: %i[id symbol_name display_name exchange segment instrument_type]
                                         }
                                       }),
      meta: {
        current_page: mis_details.current_page,
        total_pages: mis_details.total_pages,
        total_count: mis_details.total_count
      }
    }
  end

  def show
    mis_detail = MisDetail.find(params[:id])
    render json: mis_detail
  end

  def create
    mis_detail = MisDetail.new(mis_detail_params)
    if mis_detail.save
      render json: mis_detail, status: :created
    else
      render json: mis_detail.errors, status: :unprocessable_entity
    end
  end

  def update
    mis_detail = MisDetail.find(params[:id])
    if mis_detail.update(mis_detail_params)
      render json: mis_detail
    else
      render json: mis_detail.errors, status: :unprocessable_entity
    end
  end

  def destroy
    mis_detail = MisDetail.find(params[:id])
    mis_detail.destroy
    head :no_content
  end

  private

  def mis_detail_params
    params.require(:mis_detail).permit(:mis_leverage, :co_leverage, :bo_leverage, :instrument_id)
  end
end


# File: app/controllers/options/strategy_suggestions_controller.rb
# frozen_string_literal: true

module Options
  class StrategySuggestionsController < ApplicationController
    def index
      strategies = Option::SuggestStrategyService.call(
        index_symbol: strategy_params[:index_symbol],
        expiry_date: strategy_params[:expiry_date],
        params: strategy_params
      )
      render json: { strategies: strategies }
    rescue StandardError => e
      render json: { error: e.message }, status: :unprocessable_entity
    end

    private

    def strategy_params
      params.require(:option).permit(:index_symbol, :expiry_date, :outlook, :volatility, :risk, :option_preference,
                                     :target_profit, :max_loss)
    end
  end
end


# File: app/controllers/options_controller.rb
# frozen_string_literal: true

class OptionsController < ApplicationController
  def index
    strategies = Option::SuggestStrategyService.call(
      index_symbol: strategy_params[:index_symbol],
      expiry_date: strategy_params[:expiry_date],
      params: strategy_params
    )
    render json: { strategies: strategies }
  rescue StandardError => e
    render json: { error: e.message }, status: :unprocessable_entity
  end

  private

  def strategy_params
    params.require(:option).permit(:index_symbol, :expiry_date, :outlook, :volatility, :risk, :option_preference,
                                   :target_profit, :max_loss)
  end
end


# File: app/controllers/orders_controller.rb
# frozen_string_literal: true

class OrdersController < ApplicationController
  def index
    orders = OrdersService.fetch_orders
    render json: ResponseHelper.success_response(orders)
  rescue StandardError => e
    render json: ResponseHelper.error_response(e.message), status: :unprocessable_entity
  end

  def trades
    trades = OrdersService.fetch_trades
    render json: trades
  end
end


# File: app/controllers/portfolios_controller.rb
# frozen_string_literal: true

class PortfoliosController < ApplicationController
  def holdings
    holdings = PortfolioService.fetch_holdings
    render json: holdings
  end

  def positions
    positions = PortfolioService.fetch_positions
    render json: positions
  end
end


# File: app/controllers/statements_controller.rb
# frozen_string_literal: true

class StatementsController < ApplicationController
  def ledger
    ledger = StatementsService.fetch_ledger(params[:from_date], params[:to_date])
    render json: ledger
  end

  def trade_history
    history = StatementsService.fetch_trade_history(params[:from_date], params[:to_date], params[:page])
    render json: history
  end
end


# File: app/controllers/webhooks/alerts_controller.rb
# frozen_string_literal: true

module Webhooks
  class AlertsController < ApplicationController
    def create
      if instrument.nil?
        return render json: { error: 'Instrument not found for the given parameters' },
                      status: :not_found
      end

      # Build the alert with the associated instrument
      alert = instrument.alerts.build(alert_params)

      if valid_alert?(alert_params)
        if alert.save
          processor = AlertProcessorFactory.build(alert)
          processor.call

          render json: { message: 'Alert processed successfully', alert: alert }, status: :created
        else
          render json: { error: 'Failed to save alert', details: alert.errors.full_messages },
                 status: :unprocessable_entity
        end
      else
        render json: { error: 'Invalid or delayed alert' }, status: :unprocessable_entity
      end
    end

    private

    def instrument
      @instrument ||= Instrument.find_by(
        underlying_symbol: alert_params[:ticker],
        segment: segment_from_alert_type(alert_params[:instrument_type]),
        exchange: alert_params[:exchange]
      )
    end

    def alert_params
      params.require(:alert).permit(
        :ticker, :instrument_type, :order_type, :current_position, :previous_position, :strategy_type, :current_price,
        :high, :low, :volume, :time, :chart_interval, :stop_loss, :stop_price, :take_profit, :limit_price,
        :trailing_stop_loss, :strategy_name, :strategy_id, :action, :exchange
      )
    end

    # Map instrument_type to segment
    def segment_from_alert_type(instrument_type)
      case instrument_type
      when 'index' then 'index'
      when 'stock' then 'equity'
      else instrument_type # Default to the given type
      end
    end

    # Validate the alert timing and time range
    def valid_alert?(alert)
      alert_time = begin
        Time.zone.parse(alert[:time])
      rescue StandardError
        nil
      end
      alert_time.present? && recent_alert?(alert_time)
    end

    # Check if the alert time is recent (within 60 seconds)
    def recent_alert?(alert_time)
      Time.zone.now - alert_time < 20
    end

    # NOTE: NOT USED
    # Check if the alert time is within market hours (9:15 AM to 3:00 PM IST)
    def within_time_range?(alert_time)
      start_time = alert_time.beginning_of_day.change(hour: 9, min: 15)
      end_time = alert_time.beginning_of_day.change(hour: 15, min: 0)
      alert_time.between?(start_time, end_time)
    end
  end
end


# File: app/jobs/application_job.rb
# frozen_string_literal: true

class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  retry_on StandardError, attempts: 5, wait: :exponentially_longer

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError

  rescue_from(StandardError) do |exception|
    ErrorLogger.log_error('Job failed', exception)
    raise exception
  end
end


# File: app/jobs/csv_import_job.rb
# frozen_string_literal: true

class CsvImportJob < ApplicationJob
  queue_as :default

  require 'open-uri'

  def perform(*_args)
    file_path = download_file(file_url)
    CsvImporter.import(file_path)
    cleanup_file(file_path)
  end

  private

  # Downloads the file from the given URL
  def download_file(url = ENV.fetch('CSV_FILE_URL', nil))
    file_path = Rails.root.join('tmp/api-scrip-master-detailed.csv')
    File.write(file_path, URI.open(url).read)
    file_path
  end

  # Deletes the file after import
  def cleanup_file(file_path)
    FileUtils.rm_f(file_path)
  end
end


# File: app/jobs/order_manager_job.rb
# frozen_string_literal: true

class OrderManagerJob < ApplicationJob
  queue_as :default

  def perform
    Managers::Orders.call
  end
end


# File: app/jobs/position_manager_job.rb
# frozen_string_literal: true

class PositionsManagerJob < ApplicationJob
  queue_as :default

  def perform
    Managers::Positions.call
  end
end


# File: app/jobs/update_strategy_examples_job.rb
# frozen_string_literal: true

class UpdateStrategyExamplesJob < ApplicationJob
  queue_as :default

  def perform(option_chain, params)
    Option::StrategyExampleUpdater.update_examples(option_chain, params)
  end
end


# File: app/mailers/application_mailer.rb
# frozen_string_literal: true

class ApplicationMailer < ActionMailer::Base
  default from: 'from@example.com'
  layout 'mailer'
end


# File: app/models/alert.rb
# frozen_string_literal: true

class Alert < ApplicationRecord
  validates :ticker, :instrument_type, :order_type, :current_price, :time, :strategy_name, :strategy_id, presence: true
  validates :order_type, inclusion: { in: %w[market limit stop] }
  validates :current_price, :high, :low, :volume, :stop_loss, :take_profit, :trailing_stop_loss,
            numericality: { greater_than_or_equal_to: 0 }, allow_nil: true

  enum :instrument_type, {
    stock: 'stock',
    fund: 'fund',
    dr: 'dr',
    right: 'right',
    bond: 'bond',
    warrant: 'warrant',
    structured: 'structured',
    index: 'index',
    forex: 'forex',
    futures: 'futures',
    spread: 'spread',
    economic: 'economic',
    fundamental: 'fundamental',
    crypto: 'crypto',
    spot: 'spot',
    swap: 'swap',
    option: 'option',
    commodity: 'commodity'
  }, prefix: :instrument

  enum :status, { pending: 'pending', processed: 'processed', failed: 'failed' }
end


# File: app/models/application_record.rb
# frozen_string_literal: true

class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end


# File: app/models/derivative.rb
# frozen_string_literal: true

class Derivative < ApplicationRecord
  # Associations
  belongs_to :instrument

  # Validations
  validates :strike_price, :option_type, :expiry_date, presence: true
end


# File: app/models/holding.rb
# frozen_string_literal: true

class Holding < ApplicationRecord
  # Enums
  enum :exchange, { nse: 'NSE', bse: 'BSE', mcx: 'MCX', all: 'ALL' }
end


# File: app/models/instrument.rb
# frozen_string_literal: true

class Instrument < ApplicationRecord
  # Associations
  has_one :mis_detail, dependent: :destroy
  has_one :derivative, dependent: :destroy
  has_many :margin_requirements, dependent: :destroy
  has_many :order_features, dependent: :destroy
  has_many :alerts, dependent: :destroy

  # Enable nested attributes for associated models
  accepts_nested_attributes_for :derivative, allow_destroy: true
  accepts_nested_attributes_for :margin_requirements, allow_destroy: true
  accepts_nested_attributes_for :order_features, allow_destroy: true

  enum :exchange, { nse: 'NSE', bse: 'BSE' }
  enum :segment, { index: 'I', equity: 'E', currency: 'C', derivatives: 'D' }, prefix: true
  enum :instrument, {
    index: 'INDEX',
    futures_index: 'FUTIDX',
    options_index: 'OPTIDX',
    equity: 'EQUITY',
    futures_stock: 'FUTSTK',
    options_stock: 'OPTSTK',
    futures_currency: 'FUTCUR',
    options_currency: 'OPTCUR'
  }, prefix: true

  # Validations
  validates :security_id, presence: true

  # Scopes
  # scope :equities, -> { where(instrument: equities) }
  # scope :indices, -> { where(instrument: :index) }
  # scope :currencies, -> { where(segment: "C") }
  scope :expiring_soon, -> { where(expiry_flag: '1') }

  # API Methods
  def ltp
    response = Dhanhq::API::MarketFeed.ltp(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s, 'last_price') : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch LTP for Instrument #{id}: #{e.message}")
    nil
  end

  def ohlc
    response = Dhanhq::API::MarketFeed.ohlc(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch OHLC for Instrument #{id}: #{e.message}")
    nil
  end

  def depth
    response = Dhanhq::API::MarketFeed.quote(exch_segment_enum)
    response['status'] == 'success' ? response.dig('data', exchange_segment, security_id.to_s) : nil
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Depth for Instrument #{id}: #{e.message}")
    nil
  end

  def fetch_option_chain(expiry = nil)
    expiry ||= expiry_list.first
    response = Dhanhq::API::Option.chain(
      UnderlyingScrip: security_id.to_i,
      UnderlyingSeg: exchange_segment,
      Expiry: expiry
    )
    data = response['data']
    return nil unless data

    filtered_data = data['oc'].select do |_strike, option_data|
      call_data = option_data['ce']
      put_data = option_data['pe']

      has_call_values = call_data && call_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end
      has_put_values = put_data && put_data.except('implied_volatility').values.any? do |v|
        numeric_value?(v) && v.to_f.positive?
      end

      has_call_values || has_put_values
    end

    { last_price: data['last_price'], oc: filtered_data }
  rescue StandardError => e
    Rails.logger.error("Failed to fetch Option Chain for Instrument #{id}: #{e.message}")
    nil
  end

  # Helper method to check if a value is numeric
  def numeric_value?(value)
    value.is_a?(Numeric) || value.to_s.match?(/\A-?\d+(\.\d+)?\z/)
  end

  def expiry_list
    response = Dhanhq::API::Option.expiry_list(
      UnderlyingScrip: security_id,
      UnderlyingSeg: exchange_segment
    )
    response['data']
  end

  # Generate `exchange_segment` dynamically
  def exchange_segment
    case [exchange.to_sym, segment.to_sym]
    when %i[nse index] then 'IDX_I'
    when %i[bse index] then 'IDX_I'
    when %i[nse equity] then 'NSE_EQ'
    when %i[bse equity] then 'BSE_EQ'
    when %i[nse derivatives] then 'NSE_FNO'
    when %i[bse derivatives] then 'BSE_FNO'
    when %i[nse currency] then 'NSE_CURRENCY'
    when %i[bse currency] then 'BSE_CURRENCY'
    else
      raise "Unsupported exchange and segment combination: #{exchange}, #{segment}"
    end
  end

  # Define searchable attributes for Ransack
  def self.ransackable_attributes(_auth_object = nil)
    %w[
      instrument
      instrument_type
      underlying_symbol
      symbol_name
      display_name
      exchange
      segment
      created_at
      updated_at
    ]
  end

  # Define searchable associations for Ransack
  def self.ransackable_associations(_auth_object = nil)
    %w[derivatives margin_requirement mis_detail order_feature]
  end

  private

  def exch_segment_enum
    { exchange_segment => [security_id.to_i] }
  end
end


# File: app/models/margin_requirement.rb
# frozen_string_literal: true

class MarginRequirement < ApplicationRecord
  # Associations
  belongs_to :instrument

  # Validations
  validates :buy_co_min_margin_per, :sell_co_min_margin_per, numericality: { greater_than_or_equal_to: 0 },
                                                             allow_nil: true
end


# File: app/models/mis_detail.rb
# frozen_string_literal: true

class MisDetail < ApplicationRecord
  belongs_to :instrument

  validates :mis_leverage, presence: true

  # Ransack attributes
  def self.ransackable_attributes(_auth_object = nil)
    %w[id mis_leverage co_leverage bo_leverage instrument_id created_at updated_at]
  end
end


# File: app/models/order_feature.rb
# frozen_string_literal: true

class OrderFeature < ApplicationRecord
  # Associations
  belongs_to :instrument

  # Validations
  validates :bracket_flag, :cover_flag, inclusion: { in: %w[Y N] }, allow_nil: true
end


# File: app/models/order.rb
# frozen_string_literal: true

class Order < ApplicationRecord
  # Enums
  enum :transaction_type, { buy: 'BUY', sell: 'SELL' }
  enum :product_type, { cnc: 'CNC', intraday: 'INTRADAY', margin: 'MARGIN', mtf: 'MTF', co: 'CO', bo: 'BO' }
  enum :order_type, { limit: 'LIMIT', market: 'MARKET', stop_loss: 'STOP_LOSS', stop_loss_market: 'STOP_LOSS_MARKET' }
  enum :validity, { day: 'DAY', ioc: 'IOC' }
  enum :order_status,
       { transit: 'TRANSIT', pending: 'PENDING', rejected: 'REJECTED', cancelled: 'CANCELLED', traded: 'TRADED',
         expired: 'EXPIRED' }

  # Associations
  belongs_to :alert, optional: true
end


# File: app/models/position.rb
# frozen_string_literal: true

class Position < ApplicationRecord
  # Associations
  belongs_to :instrument

  # Enums
  enum :position_type, { long: 'LONG', short: 'SHORT', closed: 'CLOSED' }
  enum :product_type, { cnc: 'CNC', intraday: 'INTRADAY', margin: 'MARGIN', mtf: 'MTF', co: 'CO', bo: 'BO' }
  enum :exchange_segment,
       { nse_eq: 'NSE_EQ', nse_fno: 'NSE_FNO', bse_eq: 'BSE_EQ', bse_fno: 'BSE_FNO', mcx_comm: 'MCX_COMM' }
end


# File: app/models/strategy.rb
# frozen_string_literal: true

class Strategy < ApplicationRecord
  validates :name, presence: true, uniqueness: true
end


# File: app/services/alert_processor.rb
# frozen_string_literal: true

class AlertProcessor < ApplicationService
  def initialize(alert)
    @alert = alert
  end

  def call
    handle_open_position

    strategy = select_strategy
    raise "Strategy not found for instrument type: #{@alert[:instrument_type]}" unless strategy

    strategy.execute

    # setup_trailing_stop_loss(order_response) if order_response&.dig("orderId")

    @alert.update(status: 'processed')
  rescue StandardError => e
    @alert.update(status: 'failed', error_message: e.message)
    Rails.logger.error("Failed to process alert #{@alert.id}: #{e}")
  end

  private

  attr_reader :alert

  # Handle open positions and close them if profitable
  def handle_open_position
    position = fetch_open_position

    return unless position && position_profitable?(position)

    return unless opposite_signal?(position)

    if position_profitable?(position)
      close_position(position)
    elsif risk_reward_hit?(position)
      close_position(position)
    end
  end

  def fetch_open_position
    positions = Dhanhq::API::Portfolio.positions
    positions.find { |pos| pos['tradingSymbol'] == alert[:ticker] && pos['positionType'] != 'CLOSED' }
  end

  def position_profitable?(position)
    position['unrealizedProfit'].to_f > 20.00
  end

  def risk_reward_hit?(position)
    entry_price = position['entryPrice'].to_f
    target_price = entry_price + ((entry_price - position['stopLoss'].to_f) * 2)
    current_price = position['lastTradedPrice'].to_f
    current_price >= target_price
  end

  def opposite_signal?(position)
    alert[:action].upcase != position['positionType']
  end

  def close_position(position)
    order_data = {
      transactionType: position['positionType'] == 'LONG' ? 'SELL' : 'BUY',
      exchangeSegment: position['exchangeSegment'],
      productType: position['productType'],
      orderType: 'MARKET',
      validity: 'DAY',
      securityId: position['securityId'],
      quantity: position['netQty']
    }

    Dhanhq::API::Orders.place(order_data)
  rescue StandardError => e
    raise "Failed to close position for #{position['tradingSymbol']}: #{e.message}"
  end

  def select_strategy
    strategy_suffix = alert[:strategy_id]&.split('_')&.last

    case alert[:instrument_type].downcase
    when 'stock'
      case strategy_suffix
      when 'intraday' then Orders::Strategies::IntradayStockStrategy.new(alert)
      when 'swing'    then Orders::Strategies::SwingStockStrategy.new(alert)
      when 'long_term' then Orders::Strategies::StockOrderStrategy.new(alert)
      else
        raise "Unsupported stock strategy: #{strategy_suffix}"
      end
    when 'index'
      case strategy_suffix
      when 'intraday' then Orders::Strategies::IntradayIndexStrategy.new(alert)
      when 'swing'    then Orders::Strategies::SwingIndexStrategy.new(alert)
      else
        raise "Unsupported index strategy: #{strategy_suffix}"
      end
    else
      raise "Unsupported instrument type: #{alert[:instrument_type]}"
    end
  end
end


# File: app/services/alert_processors/base.rb
# frozen_string_literal: true

module AlertProcessors
  class Base < ApplicationService
    attr_reader :alert

    def initialize(alert)
      @alert = alert
    end

    def call
      raise NotImplementedError, "#{self.class} must implement #call"
    end

    private

    def instrument
      @instrument ||= Instrument.find_by!(
        underlying_symbol: alert[:ticker],
        segment: segment_from_alert_type(alert[:instrument_type]),
        exchange: alert[:exchange]
      )
    rescue ActiveRecord::RecordNotFound
      raise "Instrument not found for #{alert[:ticker]}"
    end

    def segment_from_alert_type(instrument_type)
      case instrument_type
      when 'index' then 'index'
      when 'stock' then 'equity'
      else instrument_type
      end
    end
  end
end


# File: app/services/alert_processors/index.rb
# frozen_string_literal: true

module AlertProcessors
  class Index < Base
    attr_reader :alert, :exchange

    def call
      expiry = instrument.expiry_list.first
      option_chain = fetch_option_chain(expiry)
      best_strike = select_best_strike(option_chain)

      raise 'Failed to find a suitable strike for trading' unless best_strike

      option_type = alert[:action].downcase == 'buy' ? 'CE' : 'PE'
      strike_price = best_strike[:strike_price]
      strike_instrument = fetch_instrument_for_strike(strike_price, expiry, option_type)

      place_order(strike_instrument, best_strike)
      @alert.update(status: 'processed')
    rescue StandardError => e
      @alert.update(status: 'failed', error_message: e.message)
      Rails.logger.error("Failed to process index alert: #{e}")
    end

    private

    def security_symbol
      instrument.symbol_name
    end

    # Fetch the instrument record
    def instrument
      @instrument ||= Instrument.find_by!(
        exchange: exchange,
        underlying_symbol: security_symbol,
        instrument_type: alert[:instrument_type] == 'stock' ? 'ES' : 'INDEX'
      )
    rescue ActiveRecord::RecordNotFound
      raise "Instrument not found for #{security_symbol} in #{exchange}"
    end

    # Fetch option chain for the specified expiry
    def fetch_option_chain(expiry)
      instrument.fetch_option_chain(expiry)
    rescue StandardError => e
      raise "Failed to fetch option chain for #{security_symbol} with expiry #{expiry}: #{e.message}"
    end

    def fetch_instrument_for_strike(strike_price, expiry_date, option_type)
      Instrument.joins(:derivative)
                .where(
                  "instruments.segment = ? AND
                   instruments.underlying_symbol = ? AND
                   instruments.instrument = ? AND
                   derivatives.strike_price = ? AND
                   derivatives.option_type = ? AND
                   derivatives.expiry_date = ?",
                  'D', # Derivatives
                  security_symbol,
                  'OPTIDX', # Options Index
                  strike_price,
                  option_type.upcase,
                  expiry_date.to_date
                )
                .first!
    rescue ActiveRecord::RecordNotFound
      raise "Instrument not found for #{security_symbol}, strike #{strike_price}, expiry #{expiry_date}, and option type #{option_type}"
    end

    # Analyze and select the best strike for trading
    def select_best_strike(option_chain)
      chain_analyzer = Option::ChainAnalyzer.new(option_chain)
      chain_analyzer.analyze

      # Determine the desired option type (CE/PE) based on the action
      option_type = alert[:action].downcase == 'buy' ? 'ce' : 'pe'

      strikes = option_chain[:oc].filter_map do |strike, data|
        next unless data[option_type]

        {
          strike_price: strike.to_i,
          last_price: data[option_type]['last_price'].to_f,
          oi: data[option_type]['oi'].to_i,
          iv: data[option_type]['implied_volatility'].to_f,
          greeks: data[option_type]['greeks']
        }
      end

      # Select based on OI, IV, and Greeks (customizable logic)
      strikes.max_by do |s|
        s[:oi] * s[:iv] * (s.dig(:greeks, :delta).abs || 0.5) # Example scoring formula
      end
    end

    # Place the order for the selected strike
    def place_order(instrument, strike)
      available_balance = fetch_available_balance
      max_allocation = available_balance * 0.5 # Use 50% of available balance
      quantity = calculate_quantity(strike[:last_price], max_allocation, instrument.lot_size)

      order_data = {
        transactionType: 'BUY',
        exchangeSegment: instrument.exchange_segment,
        productType: 'INTRADAY',
        orderType: alert[:order_type].upcase,
        validity: 'DAY',
        securityId: instrument.security_id,
        quantity: quantity,
        price: strike[:last_price],
        triggerPrice: alert[:stop_price] || strike[:last_price]
      }

      Rails.logger.debug order_data
      Dhanhq::API::Orders.place(order_data)
    rescue StandardError => e
      raise "Failed to place order for instrument #{instrument.symbol_name}: #{e.message}"
    end

    # Fetch available balance from the API
    def fetch_available_balance
      Dhanhq::API::Funds.balance['availabelBalance'].to_f
    rescue StandardError
      raise 'Failed to fetch available balance'
    end

    # Calculate the maximum quantity to trade
    def calculate_quantity(price, max_allocation, lot_size)
      max_quantity = (max_allocation / price).floor # Maximum quantity based on allocation
      adjusted_quantity = (max_quantity / lot_size) * lot_size # Adjust to nearest lot size

      [adjusted_quantity, lot_size].max # Ensure at least one lot
    end
  end
end


# File: app/services/alert_processors/stock.rb
# frozen_string_literal: true

module AlertProcessors
  class Stock < Base
    def call
      strategy = determine_strategy
      pp strategy
      execute_strategy(strategy)
      alert.update!(status: 'processed')
    rescue StandardError => e
      alert.update!(status: 'failed', error_message: e.message)
      Rails.logger.error("Failed to process stock alert: #{e.message}")
    end

    private

    def determine_strategy
      case alert[:strategy_type]
      when 'intraday'
        Orders::Strategies::IntradayStockStrategy.new(alert)
      when 'swing'
        Orders::Strategies::SwingStockStrategy.new(alert)
      when 'long_term'
        Orders::Strategies::StockOrderStrategy.new(alert)
      else
        raise "Unsupported strategy type: #{alert[:strategy_type]}"
      end
    end

    def execute_strategy(strategy)
      strategy.execute
    end
  end
end


# File: app/services/application_service.rb
# frozen_string_literal: true

class ApplicationService
  def self.call(...)
    new(...).call
  end
end


# File: app/services/csv_importer.rb
# frozen_string_literal: true

require 'csv'
require 'open-uri'

class CsvImporter
  CSV_URL = 'https://images.dhan.co/api-data/api-scrip-master-detailed.csv'

  VALID_EXCHANGES = %w[NSE BSE].freeze
  VALID_SEGMENTS = %w[D E I].freeze
  VALID_INSTRUMENTS = %w[OPTIDX FUTIDX OPTSTK FUTSTK EQUITY INDEX].freeze
  VALID_BUY_SELL_INDICATOR = %w[A].freeze # A means both Buy and Sell are allowed

  def self.import
    file_path = download_csv
    csv_data = filter_csv_data(CSV.read(file_path, headers: true))

    # Import Instruments
    import_instruments(csv_data)

    # Import Derivatives
    import_derivatives(csv_data)

    # Import Margin Requirements
    import_margin_requirements(csv_data)

    # Import Order Features
    import_order_features(csv_data)

    # Cleanup temporary file
    # File.delete(file_path) if File.exist?(file_path)

    Rails.logger.debug 'CSV Import completed successfully!'
  end

  def self.import_csv_data(file_path)
    Rails.logger.debug 'Importing filtered CSV data...'
    csv_data = filter_csv_data(CSV.read(file_path, headers: true))
    # Import Instruments
    import_instruments(csv_data)

    # Import Derivatives
    import_derivatives(csv_data)

    # Import Margin Requirements
    import_margin_requirements(csv_data)

    # Import Order Features
    import_order_features(csv_data)

    Rails.logger.debug 'Filtered CSV Import completed successfully!'
  end

  def self.download_csv
    Rails.logger.debug { "Downloading CSV from #{CSV_URL}..." }
    tmp_file = Rails.root.join('tmp/api-scrip-master-detailed.csv')
    File.binwrite(tmp_file, URI.open(CSV_URL).read)
    Rails.logger.debug { "CSV downloaded to #{tmp_file}" }
    tmp_file
  end

  def self.filter_csv_data(csv_data)
    Rails.logger.debug 'Filtering CSV data...'
    csv_data.select do |row|
      valid_instrument?(row) && valid_buy_sell_indicator?(row) && valid_expiry_date?(row)
    end
  end

  def self.import_instruments(csv_data)
    Rails.logger.debug 'Importing Instruments...'
    csv_data.each do |row|
      next if Instrument.find_by(security_id: row['SECURITY_ID'], symbol_name: row['SYMBOL_NAME'])

      Rails.logger.debug { "Importing Instrument: #{row['DISPLAY_NAME']} (#{row['INSTRUMENT']})" }

      instrument = Instrument.find_or_initialize_by(security_id: row['SECURITY_ID'], symbol_name: row['SYMBOL_NAME'])
      next unless instrument

      instrument.update(
        isin: row['ISIN'],
        instrument: row['INSTRUMENT'],
        instrument_type: row['INSTRUMENT_TYPE'],
        underlying_symbol: row['UNDERLYING_SYMBOL'],
        underlying_security_id: row['UNDERYLING_SECURITY_ID'],
        display_name: row['DISPLAY_NAME'],
        series: row['SERIES'],
        lot_size: row['LOT_SIZE'].to_i.positive? ? row['LOT_SIZE'].to_i : nil,
        tick_size: row['TICK_SIZE'],
        asm_gsm_flag: row['ASM_GSM_FLAG'],
        asm_gsm_category: row['ASM_GSM_CATEGORY'],
        mtf_leverage: row['MTF_LEVERAGE'],
        exchange: row['EXCH_ID'],
        segment: row['SEGMENT']
      )
    end
  end

  def self.import_derivatives(csv_data)
    Rails.logger.debug 'Importing Derivatives...'
    csv_data.each do |row|
      next unless row['STRIKE_PRICE'] && row['OPTION_TYPE']

      Rails.logger.debug do
        "Importing Derivatives: #{row['DISPLAY_NAME']} (#{row['INSTRUMENT']}) #{row['STRIKE_PRICE']} #{row['OPTION_TYPE']}"
      end
      expiry_date = parse_date(row['SM_EXPIRY_DATE'])
      next unless expiry_date && expiry_date >= Time.zone.today # Only upcoming expiries

      instrument = Instrument.find_by(security_id: row['SECURITY_ID'], underlying_symbol: row['UNDERLYING_SYMBOL'])
      next unless instrument

      derivative = Derivative.find_or_initialize_by(
        instrument: instrument,
        strike_price: row['STRIKE_PRICE'],
        option_type: row['OPTION_TYPE'],
        expiry_date: expiry_date
      )
      derivative.update!(expiry_flag: row['EXPIRY_FLAG'])
    end
  end

  def self.import_margin_requirements(csv_data)
    Rails.logger.debug 'Importing Margin Requirements...'
    csv_data.each do |row|
      instrument = Instrument.find_by(security_id: row['SECURITY_ID'])
      next unless instrument

      margin = MarginRequirement.find_or_initialize_by(instrument: instrument)
      margin.update!(
        buy_co_min_margin_per: row['BUY_CO_MIN_MARGIN_PER'],
        sell_co_min_margin_per: row['SELL_CO_MIN_MARGIN_PER'],
        buy_bo_min_margin_per: row['BUY_BO_MIN_MARGIN_PER'],
        sell_bo_min_margin_per: row['SELL_BO_MIN_MARGIN_PER'],
        buy_co_sl_range_max_perc: row['BUY_CO_SL_RANGE_MAX_PERC'],
        sell_co_sl_range_max_perc: row['SELL_CO_SL_RANGE_MAX_PERC'],
        buy_co_sl_range_min_perc: row['BUY_CO_SL_RANGE_MIN_PERC'],
        sell_co_sl_range_min_perc: row['SELL_CO_SL_RANGE_MIN_PERC'],
        buy_bo_sl_range_max_perc: row['BUY_BO_SL_RANGE_MAX_PERC'],
        sell_bo_sl_range_max_perc: row['SELL_BO_SL_RANGE_MAX_PERC'],
        buy_bo_sl_range_min_perc: row['BUY_BO_SL_RANGE_MIN_PERC'],
        sell_bo_sl_min_range: row['SELL_BO_SL_MIN_RANGE'],
        buy_bo_profit_range_max_perc: row['BUY_BO_PROFIT_RANGE_MAX_PERC'],
        sell_bo_profit_range_max_perc: row['SELL_BO_PROFIT_RANGE_MAX_PERC'],
        buy_bo_profit_range_min_perc: row['BUY_BO_PROFIT_RANGE_MIN_PERC'],
        sell_bo_profit_range_min_perc: row['SELL_BO_PROFIT_RANGE_MIN_PERC']
      )
    end
  end

  def self.import_order_features(csv_data)
    Rails.logger.debug 'Importing Order Features...'
    csv_data.each do |row|
      instrument = Instrument.find_by(security_id: row['SECURITY_ID'])
      next unless instrument

      feature = OrderFeature.find_or_initialize_by(instrument: instrument)
      feature.update!(
        bracket_flag: row['BRACKET_FLAG'],
        cover_flag: row['COVER_FLAG'],
        buy_sell_indicator: row['BUY_SELL_INDICATOR']
      )
    end
  end

  def self.valid_instrument?(row)
    VALID_EXCHANGES.include?(row['EXCH_ID']) && VALID_INSTRUMENTS.include?(row['INSTRUMENT']) && row['LOT_SIZE'].to_i.positive? && VALID_SEGMENTS.include?(row['SEGMENT'])
  end

  def self.valid_buy_sell_indicator?(row)
    VALID_BUY_SELL_INDICATOR.include?(row['BUY_SELL_INDICATOR'])
  end

  def self.valid_expiry_date?(row)
    return true unless row['SM_EXPIRY_DATE']

    expiry_date = parse_date(row['SM_EXPIRY_DATE'])
    expiry_date.nil? || expiry_date >= Time.zone.today
  end

  def self.parse_date(date_string)
    Date.parse(date_string)
  rescue StandardError
    nil
  end
end


# File: app/services/events/trailing_stop_loss_event.rb
# frozen_string_literal: true

class TrailingStopLossEvent
  def self.trigger(order_id, new_stop_loss)
    ActiveSupport::Notifications.instrument('order.stop_loss_updated', order_id: order_id, new_stop_loss: new_stop_loss)
  end
end


# File: app/services/exceptions/instrument_not_found_error.rb
# frozen_string_literal: true

class InstrumentNotFoundError < StandardError; end


# File: app/services/factories/alert_processor_factory.rb
# frozen_string_literal: true

class AlertProcessorFactory
  def self.build(alert)
    case alert.instrument_type
    when 'stock'
      AlertProcessors::Stock.new(alert)
    when 'index'
      AlertProcessors::Index.new(alert)
    else
      raise NotImplementedError, "Unsupported instrument type: #{alert.instrument_type}"
    end
  end
end


# File: app/services/factories/strategy_factory.rb
# frozen_string_literal: true

class StrategyFactory
  def self.for_stock(alert)
    case alert.strategy_type
    when 'intraday'
      Strategies::Stock::IntradayStrategy.new(alert)
    when 'swing'
      Strategies::Stock::SwingStrategy.new(alert)
    when 'long_term'
      Strategies::Stock::LongTermStrategy.new(alert)
    else
      raise NotImplementedError, "Unsupported stock strategy type: #{alert.strategy_type}"
    end
  end

  def self.for_index(alert)
    case alert.strategy_type
    when 'intraday'
      Strategies::Index::IntradayStrategy.new(alert)
    when 'swing'
      Strategies::Index::SwingStrategy.new(alert)
    else
      raise NotImplementedError, "Unsupported index strategy type: #{alert.strategy_type}"
    end
  end
end


# File: app/services/funds_service.rb
# frozen_string_literal: true

class FundsService
  def self.fetch_funds
    retries ||= 0
    Dhanhq::API::Funds.balance
  rescue StandardError => e
    ErrorHandler.handle_error(
      context: 'Fetching funds',
      exception: e,
      retries: retries + 1,
      retry_logic: -> { fetch_funds }
    )
  end
end


# File: app/services/managers/base.rb
# frozen_string_literal: true

module Managers
  class Base
    def self.call(*args)
      new(*args).call
    end

    def log_info(message)
      Rails.logger.info(message)
    end

    def log_error(message, exception = nil)
      Rails.logger.error("#{message}: #{exception&.message}")
    end

    def execute_safely
      yield
    rescue StandardError => e
      log_error('Error during execution', e)
      raise e
    end
  end
end


# File: app/services/managers/orders/stop_loss_manager.rb
# frozen_string_literal: true

module Managers
  module Orders
    class StopLossManager < Managers::Base
      def initialize(order, market_price)
        @order = order
        @market_price = market_price
      end

      def call
        execute_safely do
          adjust_stop_loss
        end
      end

      private

      def adjust_stop_loss
        new_stop_loss = calculate_new_stop_loss
        if new_stop_loss == @order.stop_loss_price
          log_info("No adjustment needed for order #{@order.id}")
        else
          update_stop_loss_order(new_stop_loss)
        end
      end

      def calculate_new_stop_loss
        (@market_price * 0.98).round(2) # Adjust to 2% below the current market price
      end

      def update_stop_loss_order(new_stop_loss)
        response = Dhanhq::API::Orders.modify(order_id: @order.dhan_order_id, stop_loss_price: new_stop_loss)
        if response['status'] == 'success'
          @order.update(stop_loss_price: new_stop_loss)
          log_info("Stop-loss updated for order #{@order.id} to #{new_stop_loss}")
        else
          log_error("Failed to update stop-loss for order #{@order.id}", response['error'])
        end
      end
    end
  end
end


# File: app/services/managers/orders.rb
# frozen_string_literal: true

module Managers
  class Orders < Base
    def call
      execute_safely do
        process_pending_orders
      end
    end

    def fetch_orders
      execute_safely do
        Dhanhq::API::Orders.list
      rescue StandardError => e
        log_error('Error fetching orders', e)
        { error: e.message }
      end
    end

    def fetch_trades
      execute_safely do
        Dhanhq::API::Orders.trades
      rescue StandardError => e
        log_error('Error fetching trades', e)
        { error: e.message }
      end
    end

    def place_order(ticker:, action:, quantity:, price:, security_id:, trailing_stop_loss: nil)
      execute_safely do
        response = Dhanhq::API::Orders.place(
          transactionType: action.upcase,
          exchangeSegment: 'NSE_EQ',
          productType: 'CNC',
          orderType: 'MARKET',
          securityId: security_id,
          quantity: quantity,
          price: price
        )

        Order.create(
          ticker: ticker,
          action: action,
          quantity: quantity,
          price: price,
          dhan_order_id: response['orderId'],
          dhan_status: response['orderStatus'],
          security_id: security_id,
          stop_loss_price: calculate_stop_loss(price, action, trailing_stop_loss),
          take_profit_price: calculate_take_profit(price)
        )
      rescue StandardError => e
        log_error('Failed to place order', e)
        raise
      end
    end

    def calculate_stop_loss(price, action, trailing_stop_loss)
      return unless trailing_stop_loss

      action == 'BUY' ? price - trailing_stop_loss : price + trailing_stop_loss
    end

    private

    def process_pending_orders
      Order.where(order_status: %w[pending transit]).find_each do |order|
        if order.valid?
          place_order(order)
        else
          cancel_order(order)
        end
      rescue StandardError => e
        log_error("Failed to process order #{order.id}", e)
      end
    end

    def place_order(order)
      response = Dhanhq::API::Orders.place(order.to_api_params)
      if response['status'] == 'success'
        order.update(
          order_status: :traded,
          dhan_order_id: response['orderId'],
          traded_quantity: response['data']&.[]('tradedQuantity'),
          traded_price: response['data']&.[]('tradedPrice')
        )
        log_info("Order placed successfully: #{order.id}")
      else
        order.update(order_status: :failed, error_message: response['error'])
        log_error("Failed to place order: #{order.id}", response['error'])
      end
    rescue StandardError => e
      log_error("Error placing order #{order.id}", e)
    end

    def cancel_order(order)
      order.update(order_status: :cancelled)
      log_info("Order cancelled: #{order.id}")
    end

    def update_order_status(order)
      response = Dhanhq::API::Orders.status(order.dhan_order_id)
      return unless response['status'] == 'success'

      order.update(
        order_status: response['data']['status'],
        traded_quantity: response['data']['tradedQuantity'],
        traded_price: response['data']['tradedPrice']
      )
      log_info("Order status updated for #{order.id}")
    rescue StandardError => e
      log_error("Failed to update order status for #{order.dhan_order_id}", e)
    end
  end
end


# File: app/services/managers/positions/adjust_stop_loss_manager.rb
# frozen_string_literal: true

module Managers
  module Positions
    class AdjustStopLossManager < Managers::Base
      def call
        execute_safely do
          adjust_stop_loss_for_positions
        end
      end

      private

      def adjust_stop_loss_for_positions
        Position.open.each do |position|
          adjust_stop_loss_for_position(position)
        end
      end

      def adjust_stop_loss_for_position(position)
        new_stop_loss = calculate_new_stop_loss(position)
        if new_stop_loss > position.stop_loss_price
          update_stop_loss(position, new_stop_loss)
        else
          log_info("No adjustment needed for position #{position.id}")
        end
      end

      def calculate_new_stop_loss(position)
        current_price = position.current_market_price
        trailing_amount = position.trailing_stop_loss

        if position.position_type == 'LONG'
          [current_price - trailing_amount, position.stop_loss_price].max
        else
          [current_price + trailing_amount, position.stop_loss_price].min
        end.round(2)
      end

      def update_stop_loss(position, new_stop_loss)
        response = Dhanhq::API::Orders.modify(
          order_id: position.order_id,
          stop_loss_price: new_stop_loss
        )
        if response['status'] == 'success'
          position.update(stop_loss_price: new_stop_loss)
          log_info("Stop-loss updated for position #{position.id} to #{new_stop_loss}")
        else
          log_error("Failed to update stop-loss for position #{position.id}", response['error'])
        end
      end
    end
  end
end


# File: app/services/managers/positions.rb
# frozen_string_literal: true

module Positions
  class Manager < Managers::Base
    def call
      execute_safely do
        manage_positions
        adjust_stop_loss_for_positions
      end
    end

    private

    def manage_positions
      Position.open.each do |position|
        close_position_if_profitable(position)
      end
    end

    def close_position_if_profitable(position)
      if profitable?(position)
        close_position(position)
      else
        log_info("Position not profitable: #{position.id}")
      end
    end

    def profitable?(position)
      position.unrealized_profit >= position.entry_price * 0.02 # Example: 2% profit threshold
    end

    def close_position(position)
      response = Dhanhq::API::Orders.place(close_order_params(position))
      if response['status'] == 'success'
        position.update(status: :closed)
        log_info("Position closed: #{position.id}")
      else
        log_error("Failed to close position: #{position.id}")
      end
    end

    def close_order_params(position)
      {
        transactionType: position.position_type == 'LONG' ? 'SELL' : 'BUY',
        orderType: 'MARKET',
        productType: position.product_type,
        securityId: position.security_id,
        quantity: position.net_qty
      }
    end

    def adjust_stop_loss_for_positions
      Position.open.each do |position|
        adjust_stop_loss_for_position(position)
      end
    end

    def adjust_stop_loss_for_position(position)
      new_stop_loss = calculate_new_stop_loss(position)
      if new_stop_loss > position.stop_loss_price
        update_stop_loss(position, new_stop_loss)
      else
        log_info("No adjustment needed for position #{position.id}")
      end
    end

    def calculate_new_stop_loss(position)
      current_price = position.current_market_price
      trailing_amount = position.trailing_stop_loss

      if position.position_type == 'LONG'
        [current_price - trailing_amount, position.stop_loss_price].max
      else
        [current_price + trailing_amount, position.stop_loss_price].min
      end.round(2)
    end

    def update_stop_loss(position, new_stop_loss)
      response = Dhanhq::API::Orders.modify(
        order_id: position.order_id,
        stop_loss_price: new_stop_loss
      )
      if response['status'] == 'success'
        position.update(stop_loss_price: new_stop_loss)
        log_info("Stop-loss updated for position #{position.id} to #{new_stop_loss}")
      else
        log_error("Failed to update stop-loss for position #{position.id}", response['error'])
      end
    end

    def trail_stop_loss_for_positions
      Position.open.each do |position|
        new_stop_loss = calculate_trailing_stop_loss(position)
        update_stop_loss(position, new_stop_loss) if new_stop_loss != position.stop_loss_price
      end
    end

    def calculate_trailing_stop_loss(position)
      entry_price = position.entry_price
      current_price = position.current_market_price
      trailing_amount = position.trailing_stop_loss

      return position.stop_loss_price if current_price <= entry_price

      if position.position_type == 'LONG'
        current_price - trailing_amount
      else
        current_price + trailing_amount
      end.round(2)
    end
  end
end


# File: app/services/market_data/live_market_feed_service.rb


# File: app/services/market_data/option_chain_service.rb


# File: app/services/market_feed/adjustment_strategy.rb
# frozen_string_literal: true

module MarketFeed
  class AdjustmentStrategy
    def initialize(data)
      @data = data
    end

    def adjust
      # Example: Place limit orders or adjust stop-losses
      Rails.logger.info "Adjusting strategy for #{@data['SecurityId']}"
    end
  end
end


# File: app/services/market_feed/data_processor.rb
# frozen_string_literal: true

module MarketFeed
  class DataProcessor
    def initialize(data)
      @data = data
    end

    def process
      # Example logic: Parse and handle the market feed
      update_strategy if significant_movement?
    end

    private

    def significant_movement?
      # Implement logic to detect significant price changes
      @data['priceChange'] > 1.0
    end

    def update_strategy
      MarketFeed::AdjustmentStrategy.new(@data).adjust
    end
  end
end


# File: app/services/market_feed/handlers/full_packet_handler.rb
# frozen_string_literal: true

module MarketFeed
  module Handlers
    class FullPacketHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1('F'),
          last_traded_quantity: @io.read(2).unpack1('n'),
          last_traded_time: @io.read(4).unpack1('N'),
          average_trade_price: @io.read(4).unpack1('F'),
          volume: @io.read(4).unpack1('N'),
          open_interest: @io.read(4).unpack1('N'),
          day_high: @io.read(4).unpack1('F'),
          day_low: @io.read(4).unpack1('F'),
          market_depth: parse_market_depth
        }
      end

      private

      def parse_market_depth
        Array.new(5) do
          {
            bid_quantity: @io.read(4).unpack1('N'),
            ask_quantity: @io.read(4).unpack1('N'),
            bid_orders: @io.read(2).unpack1('n'),
            ask_orders: @io.read(2).unpack1('n'),
            bid_price: @io.read(4).unpack1('F'),
            ask_price: @io.read(4).unpack1('F')
          }
        end
      end
    end
  end
end


# File: app/services/market_feed/handlers/quote_handler.rb
# frozen_string_literal: true

module MarketFeed
  module Handlers
    class QuoteHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1('F'),
          last_traded_quantity: @io.read(2).unpack1('n'),
          last_traded_time: @io.read(4).unpack1('N'),
          average_trade_price: @io.read(4).unpack1('F'),
          volume: @io.read(4).unpack1('N'),
          total_sell_quantity: @io.read(4).unpack1('N'),
          total_buy_quantity: @io.read(4).unpack1('N'),
          day_open: @io.read(4).unpack1('F'),
          day_high: @io.read(4).unpack1('F'),
          day_low: @io.read(4).unpack1('F')
        }
      end
    end
  end
end


# File: app/services/market_feed/handlers/ticker_handler.rb
# frozen_string_literal: true

module MarketFeed
  module Handlers
    class TickerHandler
      def initialize(io)
        @io = io
      end

      def parse_payload
        {
          last_traded_price: @io.read(4).unpack1('F'), # Float
          last_traded_time: @io.read(4).unpack1('N')   # Unsigned 32-bit
        }
      end
    end
  end
end


# File: app/services/market_feed/packet_parser.rb
# frozen_string_literal: true

module MarketFeed
  class PacketParser
    def self.parse(binary_data)
      # Convert binary data into a readable format
      io = StringIO.new(binary_data)

      # Parse the Response Header
      response_code = io.read(1).unpack1('C') # Unsigned char
      message_length = io.read(2).unpack1('n') # Unsigned 16-bit (big-endian)
      exchange_segment = io.read(1).unpack1('C') # Unsigned char
      security_id = io.read(4).unpack1('N') # Unsigned 32-bit (big-endian)

      # Fetch Payload Handler
      handler = handler_for_response_code(response_code)
      payload = handler&.new(io)&.parse_payload

      {
        response_code: response_code,
        message_length: message_length,
        exchange_segment: exchange_segment,
        security_id: security_id,
        payload: payload
      }
    end

    def self.handler_for_response_code(response_code)
      case response_code
      when 2
        Handlers::TickerHandler
      when 4
        Handlers::QuoteHandler
      when 8
        Handlers::FullPacketHandler
      else
        nil # Unknown handler
      end
    end
  end
end


# File: app/services/market_feed_subscription_service.rb
# frozen_string_literal: true

class MarketFeedSubscriptionService
  def self.subscribe_to_equities
    instruments = Instrument.equities.limit(1000).pluck(:exchange_segment, :security_id)
    formatted_instruments = instruments.map do |segment, id|
      { exchange_segment: segment, security_id: id }
    end

    live_feed = LiveMarketFeed.new
    live_feed.subscribe_to_instruments(formatted_instruments)
  end
end


# File: app/services/option/chain_analyzer.rb
# frozen_string_literal: true

module Option
  class ChainAnalyzer
    attr_reader :options_chain

    def initialize(options_chain)
      @options_chain = options_chain.with_indifferent_access
    end

    def analyze
      {
        max_pain: calculate_max_pain,
        support_resistance: analyze_support_resistance,
        greeks_summary: analyze_greeks,
        volatility_trends: analyze_volatility,
        price_action_trends: analyze_price_action
      }
    end

    private

    def calculate_max_pain
      strikes = @options_chain[:oc].keys
      strikes.map do |strike|
        oi_call = @options_chain.dig(:oc, strike, :ce, :oi).to_i
        oi_put = @options_chain.dig(:oc, strike, :pe, :oi).to_i
        [strike.to_f, oi_call + oi_put]
      end.min_by { |_strike, combined_oi| combined_oi }&.first
    end

    def analyze_support_resistance
      calls = fetch_oi_data(:ce)
      pe = fetch_oi_data(:pe)

      {
        resistance: calls.max_by { |c| c[:oi] }&.dig(:strike),
        support: pe.max_by { |p| p[:oi] }&.dig(:strike)
      }
    end

    def analyze_greeks
      %w[delta gamma theta vega].each_with_object({}) do |greek, summary|
        values = collect_greek_values(greek)

        summary[greek] = average(values) if values.any?
      end
    end

    def analyze_volatility
      iv_data = collect_iv_data
      {
        average_iv: average(iv_data),
        iv_trend: trend(iv_data)
      }
    end

    def analyze_price_action
      prices = @options_chain[:oc]&.values&.map { |data| data.dig('ce', 'last_price').to_f } || []

      return { bullish: false, bearish: false, neutral: true } if prices.empty? || prices.size < 5

      # Moving Averages
      short_term_ma = moving_average(prices, 5)
      long_term_ma = moving_average(prices, 20)

      {
        bullish: short_term_ma.last > long_term_ma.last,
        bearish: short_term_ma.last < long_term_ma.last,
        neutral: short_term_ma.last == long_term_ma.last
      }
    end

    def fetch_oi_data(type)
      @options_chain[:oc].filter_map do |strike, data|
        { strike: strike.to_f, oi: data.dig(type, :oi).to_i } if data[type]
      end
    end

    def collect_greek_values(greek)
      @options_chain[:oc].values.flat_map do |data|
        [data.dig(:ce, :greeks, greek), data.dig(:pe, :greeks, greek)].compact
      end
    end

    def collect_iv_data
      @options_chain[:oc].values.flat_map do |data|
        [data.dig(:ce, :implied_volatility), data.dig(:pe, :implied_volatility)].compact
      end
    end

    def average(values)
      values.sum / values.size
    end

    def trend(values)
      return 'neutral' if values.empty? || values.size < 2

      values.last > values.first ? 'increasing' : 'decreasing'
    end

    def bullish_trend?(prices, volumes)
      moving_average(prices, 5).last > moving_average(prices, 20).last && increasing?(volumes)
    end

    def bearish_trend?(prices, volumes)
      moving_average(prices, 5).last < moving_average(prices, 20).last && decreasing?(volumes)
    end

    def moving_average(data, period)
      data.each_cons(period).map { |slice| slice.sum / slice.size.to_f }
    end

    def increasing?(data)
      data.each_cons(2).all? { |a, b| b >= a }
    end

    def decreasing?(data)
      data.each_cons(2).all? { |a, b| b <= a }
    end
  end
end


# File: app/services/option/strategy_example_updater.rb
# frozen_string_literal: true

module Option
  class StrategyExampleUpdater
    def self.update_examples(option_chain, params)
      Strategy.find_each do |strategy|
        suggester = StrategySuggester.new(option_chain, params)
        example = suggester.generate_example(strategy.name)
        strategy.update(example: example) if example.is_a?(String)
      end
    end
  end
end


# File: app/services/option/strategy_suggester.rb
# frozen_string_literal: true

module Option
  class StrategySuggester
    def initialize(option_chain, params)
      @option_chain = option_chain.with_indifferent_access
      @params = params
      @current_price = option_chain[:last_price].to_f
    end

    def suggest(criteria)
      strategies = Strategy.all
      strategies = apply_filters(strategies, criteria)

      strategies.map { |strategy| format_strategy(strategy, criteria[:analysis]) }
    end

    private

    def apply_filters(strategies, criteria)
      strategies = filter_by_outlook(strategies, criteria[:outlook]) if criteria[:outlook]
      strategies = filter_by_volatility(strategies, criteria[:volatility]) if criteria[:volatility]
      strategies = filter_by_risk(strategies, criteria[:risk]) if criteria[:risk]
      strategies
    end

    def format_strategy(strategy, analysis)
      {
        name: strategy.name,
        example: send("generate_#{strategy.name.parameterize(separator: '_')}", analysis),
        analysis: analysis
      }
    end

    # Individual strategy methods
    def generate_long_call(_analysis)
      call_option = best_option('ce')
      return unless call_option

      {
        action: "Buy #{call_option[:symbol]} @ #{call_option[:last_price]}",
        max_loss: call_option[:last_price],
        max_profit: 'Unlimited (depending on price rise)',
        breakeven: call_option[:strike_price] + call_option[:last_price]
      }
    end

    def generate_long_put(_analysis)
      put_option = best_option('pe')
      return unless put_option

      {
        action: "Buy #{put_option[:symbol]} @ #{put_option[:last_price]}",
        max_loss: put_option[:last_price],
        max_profit: 'Substantial if the price drops sharply',
        breakeven: put_option[:strike_price] - put_option[:last_price]
      }
    end

    def generate_long_straddle(_analysis)
      call_option = best_option('ce')
      put_option = best_option('pe')
      return unless call_option && put_option

      {
        action: "Buy #{call_option[:symbol]} @ #{call_option[:last_price]} and #{put_option[:symbol]} @ #{put_option[:last_price]}",
        max_loss: call_option[:last_price] + put_option[:last_price],
        max_profit: 'Unlimited if price moves significantly in either direction',
        breakeven: [
          @current_price - (call_option[:last_price] + put_option[:last_price]),
          @current_price + (call_option[:last_price] + put_option[:last_price])
        ]
      }
    end

    def generate_long_strangle(_analysis)
      call_option = far_option('ce', 'OTM')
      put_option = far_option('pe', 'OTM')
      return unless call_option && put_option

      {
        action: "Buy #{call_option[:symbol]} @ #{call_option[:last_price]} and #{put_option[:symbol]} @ #{put_option[:last_price]}",
        max_loss: call_option[:last_price] + put_option[:last_price],
        max_profit: 'Unlimited if price moves sharply in either direction',
        breakeven: [
          put_option[:strike_price] - call_option[:last_price],
          call_option[:strike_price] + put_option[:last_price]
        ]
      }
    end

    def generate_long_butterfly_spread(_analysis)
      itm_option = far_option('pe', 'ITM')
      atm_option = best_option('pe')
      otm_option = far_option('pe', 'OTM')
      return unless itm_option && atm_option && otm_option

      {
        action: "Buy #{itm_option[:symbol]} and #{otm_option[:symbol]}, Sell #{atm_option[:symbol]}",
        max_loss: 'Net premium paid',
        max_profit: 'Limited but occurs if price stays near the middle strike',
        breakeven: [
          itm_option[:strike_price] - (atm_option[:last_price] + otm_option[:last_price]),
          otm_option[:strike_price] + (atm_option[:last_price] + otm_option[:last_price])
        ]
      }
    end

    def generate_long_calendar_spread(_analysis)
      long_option = best_option('ce')
      short_option = far_option('ce', 'OTM')
      return unless long_option && short_option

      {
        action: "Buy #{long_option[:symbol]} (long-dated) and Sell #{short_option[:symbol]} (near-dated)",
        max_loss: long_option[:last_price] - short_option[:last_price],
        max_profit: 'Moderate if price moves in anticipated direction slowly',
        breakeven: 'Depends on time decay differences'
      }
    end

    def generate_long_iron_condor(_analysis)
      call_buy = far_option('ce', 'OTM')
      put_buy = far_option('pe', 'OTM')
      call_sell = best_option('ce')
      put_sell = best_option('pe')
      return unless call_buy && put_buy && call_sell && put_sell

      {
        action: "Buy #{call_buy[:symbol]} and #{put_buy[:symbol]}, Sell #{call_sell[:symbol]} and #{put_sell[:symbol]}",
        max_loss: (call_buy[:last_price] + put_buy[:last_price]) - (call_sell[:last_price] + put_sell[:last_price]),
        max_profit: (call_sell[:last_price] + put_sell[:last_price]) - (call_buy[:last_price] + put_buy[:last_price]),
        breakeven: [
          call_sell[:strike_price] - (call_sell[:last_price] + put_sell[:last_price]),
          put_sell[:strike_price] + (call_sell[:last_price] + put_sell[:last_price])
        ]
      }
    end

    def generate_long_vega_volatility_play(_analysis)
      otm_option = far_option('ce', 'OTM')
      return unless otm_option

      {
        action: "Buy #{otm_option[:symbol]} @ #{otm_option[:last_price]}",
        max_loss: otm_option[:last_price],
        max_profit: 'Depends on IV increase before significant movement',
        breakeven: 'Depends on volatility shift'
      }
    end

    def generate_protective_long_put(_analysis)
      put_option = best_option('pe')
      return unless put_option

      {
        action: "Buy #{put_option[:symbol]} @ #{put_option[:last_price]} to hedge",
        max_loss: put_option[:last_price],
        max_profit: 'Unlimited (depending on downside risk)',
        breakeven: put_option[:strike_price] - put_option[:last_price]
      }
    end

    def generate_long_ratio_backspread(_analysis)
      otm_option_1 = far_option('ce', 'OTM')
      otm_option_2 = far_option('ce', 'OTM')
      itm_option = best_option('ce')
      return unless otm_option_1 && otm_option_2 && itm_option

      {
        action: "Buy 2 #{otm_option_1[:symbol]} and Sell 1 #{itm_option[:symbol]}",
        max_loss: itm_option[:last_price] - (otm_option_1[:last_price] * 2),
        max_profit: 'High if price moves significantly in expected direction',
        breakeven: 'Depends on sharp price movements'
      }
    end

    def generate_iron_butterfly(_analysis)
      call_sell = best_option('ce')
      put_sell = best_option('pe')
      call_buy = far_option('ce', 'OTM')
      put_buy = far_option('pe', 'OTM')
      return unless call_sell && put_sell && call_buy && put_buy

      {
        action: "Sell #{call_sell[:symbol]} and #{put_sell[:symbol]}, Buy #{call_buy[:symbol]} and #{put_buy[:symbol]}",
        max_loss: (call_buy[:last_price] + put_buy[:last_price]) - (call_sell[:last_price] + put_sell[:last_price]),
        max_profit: (call_sell[:last_price] + put_sell[:last_price]) - (call_buy[:last_price] + put_buy[:last_price]),
        breakeven: [
          call_sell[:strike_price] - (call_sell[:last_price] + put_sell[:last_price]),
          put_sell[:strike_price] + (call_sell[:last_price] + put_sell[:last_price])
        ]
      }
    end

    def generate_short_straddle(_analysis)
      call_option = best_option('ce')
      put_option = best_option('pe')
      return { error: 'Required options not found' } unless call_option && put_option

      {
        action: "Sell #{call_option[:symbol]} @ #{call_option[:last_price]} and Sell #{put_option[:symbol]} @ #{put_option[:last_price]}",
        max_loss: 'Unlimited (if the price moves significantly in either direction)',
        max_profit: call_option[:last_price] + put_option[:last_price],
        breakeven: [
          @current_price - (call_option[:last_price] + put_option[:last_price]),
          @current_price + (call_option[:last_price] + put_option[:last_price])
        ]
      }
    end

    def generate_short_strangle(_analysis)
      call_option = far_option('ce', 'OTM')
      put_option = far_option('pe', 'OTM')
      return { error: 'Required options not found' } unless call_option && put_option

      {
        action: "Sell #{call_option[:symbol]} @ #{call_option[:last_price]} and Sell #{put_option[:symbol]} @ #{put_option[:last_price]}",
        max_loss: 'Unlimited (if price moves significantly beyond OTM strikes)',
        max_profit: call_option[:last_price] + put_option[:last_price],
        breakeven: [
          put_option[:strike_price] - (call_option[:last_price] + put_option[:last_price]),
          call_option[:strike_price] + (call_option[:last_price] + put_option[:last_price])
        ]
      }
    end

    def generate_bull_call_spread(_analysis)
      call_buy = best_option('ce') # Closest strike price to the current price
      call_sell = far_option('ce', 'OTM') # OTM option for the spread

      return { error: 'Required options not found for Bull Call Spread strategy' } unless call_buy && call_sell

      {
        action: "Buy #{call_buy[:symbol]} @ #{call_buy[:last_price]} and Sell #{call_sell[:symbol]} @ #{call_sell[:last_price]}",
        max_loss: call_buy[:last_price] - call_sell[:last_price],
        max_profit: (call_sell[:strike_price] - call_buy[:strike_price]) - (call_buy[:last_price] - call_sell[:last_price]),
        breakeven: call_buy[:strike_price] + (call_buy[:last_price] - call_sell[:last_price])
      }
    end

    def generate_bear_put_spread(_analysis)
      put_buy = best_option('pe') # Closest strike price to the current price
      put_sell = far_option('pe', 'OTM') # OTM option for the spread

      return { error: 'Required options not found for Bear Put Spread strategy' } unless put_buy && put_sell

      {
        action: "Buy #{put_buy[:symbol]} @ #{put_buy[:last_price]} and Sell #{put_sell[:symbol]} @ #{put_sell[:last_price]}",
        max_loss: put_buy[:last_price] - put_sell[:last_price],
        max_profit: (put_buy[:strike_price] - put_sell[:strike_price]) - (put_buy[:last_price] - put_sell[:last_price]),
        breakeven: put_buy[:strike_price] - (put_buy[:last_price] - put_sell[:last_price])
      }
    end

    # Additional methods for other strategies can follow the same structure.

    def best_option(type)
      options = @option_chain[:oc].filter_map do |strike, data|
        next unless data[type]

        {
          strike_price: strike.to_f,
          last_price: data[type]['last_price'].to_f,
          symbol: "#{@params[:index_symbol]}-#{strike}-#{type.upcase}"
        }
      end
      options.min_by { |o| (o[:strike_price] - @current_price).abs }
    end

    def far_option(type, position)
      options = @option_chain[:oc].filter_map do |strike, data|
        next unless data[type]

        {
          strike_price: strike.to_f,
          last_price: data[type]['last_price'].to_f,
          symbol: "#{@params[:index_symbol]}-#{strike}-#{type.upcase}"
        }
      end

      case position
      when 'OTM'
        options.select { |o| o[:strike_price] > @current_price }.min_by { |o| o[:strike_price] - @current_price }
      when 'ITM'
        options.select { |o| o[:strike_price] < @current_price }.max_by { |o| o[:strike_price] }
      end
    end
  end
end


# File: app/services/option/suggest_strategy_service.rb
# frozen_string_literal: true

module Option
  class SuggestStrategyService
    def self.call(index_symbol:, expiry_date:, params:)
      instrument = Instrument.segment_index.find_by(underlying_symbol: index_symbol)
      raise "Invalid index symbol. #{index_symbol}" unless instrument

      expiry = instrument.expiry_list.find { |e| e['Expiry'] == expiry_date } || instrument.expiry_list.first
      option_chain = instrument.fetch_option_chain(expiry)

      analysis = ChainAnalyzer.new(option_chain).analyze
      suggester = StrategySuggester.new(option_chain, params)

      suggester.suggest(analysis: analysis)
    end
  end
end


# File: app/services/order_params_builder.rb
# frozen_string_literal: true

class OrderParamsBuilder
  def self.build(alert:, instrument:, funds:, leverage: 1.0, utilization: 0.3)
    quantity = calculate_quantity(instrument, funds, leverage, utilization)
    {
      transactionType: alert[:action].upcase,
      orderType: alert[:order_type].upcase,
      productType: alert[:strategy_type] == 'intraday' ? 'INTRADAY' : 'CNC',
      validity: 'DAY',
      securityId: instrument.security_id,
      exchangeSegment: instrument.exchange_segment,
      quantity: quantity,
      price: alert[:current_price]
    }
  end

  def self.calculate_quantity(instrument, funds, leverage, utilization)
    max_funds = funds * utilization * leverage
    (max_funds / instrument.lot_size).floor
  end
end


# File: app/services/orders/strategies/base_strategy.rb
# frozen_string_literal: true

module Orders
  module Strategies
    class BaseStrategy
      attr_reader :alert, :security_symbol, :exchange

      def initialize(alert)
        @alert = alert
        @security_symbol = alert[:ticker]
        @exchange = alert[:exchange]
      end

      def execute
        raise NotImplementedError, "#{self.class} must implement #execute"
      end

      private

      # Fetch the instrument record for stock type
      def instrument
        @instrument ||= Instrument.find_by!(
          exchange: exchange,
          underlying_symbol: security_symbol,
          segment: 'equity' # Only process stocks
        )
      rescue ActiveRecord::RecordNotFound
        raise "Instrument not found for #{security_symbol} in #{exchange}"
      end

      # Fetch available funds
      def fetch_funds
        Dhanhq::API::Funds.balance['availabelBalance'].to_f
      rescue StandardError => e
        raise "Failed to fetch funds: #{e.message}"
      end

      # Prepare common order parameters for stock
      def dhan_order_params
        {
          transactionType: alert[:action].upcase,
          orderType: alert[:order_type].upcase,
          productType: default_product_type,
          validity: Dhanhq::Constants::DAY,
          securityId: instrument.security_id,
          exchangeSegment: instrument.exchange_segment,
          quantity: calculate_quantity(alert[:current_price])
        }
      end

      # Map exchange segments dynamically
      def map_exchange_segment(exchange)
        Dhanhq::Constants::EXCHANGE_SEGMENTS.find { |seg| seg.include?(exchange) } ||
          raise("Unsupported exchange: #{exchange}")
      end

      def calculate_quantity(price)
        utilized_funds = fetch_funds * funds_utilization * leverage_factor
        max_quantity = (utilized_funds / price).floor
        [max_quantity, 1].max
      end

      def leverage_factor
        1.0 # Default leverage is 1x
      end

      def funds_utilization
        0.3 # 30% utilization of funds
      end

      # Default product type (can be overridden by subclasses)
      def default_product_type
        Dhanhq::Constants::INTRA # Default to intraday
      end

      # Place an order using Dhan API
      def place_order(params)
        Rails.logger.debug params
        Dhanhq::API::Orders.place(params)
      rescue StandardError => e
        raise "Failed to place order: #{e.message}"
      end
    end
  end
end


# File: app/services/orders/strategies/intraday_stock_strategy.rb
# frozen_string_literal: true

module Orders
  module Strategies
    class IntradayStockStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params.merge(productType: Dhanhq::Constants::INTRA))
      end

      private

      def leverage_factor
        mis_detail = instrument.mis_detail
        mis_detail&.mis_leverage.to_i || 1 # Use MIS leverage if available, default to 1x
      end

      def calculate_quantity(price)
        available_funds = fetch_funds * 0.3 # Use 30% of available funds
        max_quantity = (available_funds / price).floor
        [max_quantity, 1].max # Ensure at least 1 quantity
      end
    end
  end
end


# File: app/services/orders/strategies/stock_order_strategy.rb
# frozen_string_literal: true

module Orders
  module Strategies
    class StockOrderStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params)
      end
    end
  end
end


# File: app/services/orders/strategies/swing_stock_strategy.rb
# frozen_string_literal: true

module Orders
  module Strategies
    class SwingStockStrategy < BaseStrategy
      def execute
        place_order(dhan_order_params.merge(productType: Dhanhq::Constants::CNC))
      end

      private

      def default_product_type
        Dhanhq::Constants::CNC # Delivery-based product
      end
    end
  end
end


# File: app/services/orders_service.rb
# frozen_string_literal: true

class OrdersService
  def self.fetch_orders
    retries ||= 0
    Dhanhq::API::Orders.list
  rescue StandardError => e
    ErrorHandler.handle_error(
      context: 'Fetching orders',
      exception: e,
      retries: retries + 1,
      retry_logic: -> { fetch_orders }
    )
  end
end


# File: app/services/parsers/market_feed_parser.rb
# frozen_string_literal: true

module Parsers
  class LiveOrderParser
    REQUIRED_FIELDS = %w[
      Exchange Segment Source SecurityId ClientId ExchOrderNo OrderNo Product
      TxnType OrderType Validity RemainingQuantity Quantity TradedQty Price
      TriggerPrice TradedPrice AvgTradedPrice OrderDateTime ExchOrderTime
      LastUpdatedTime Remarks Status Symbol DisplayName Isin
    ].freeze

    def initialize(raw_data)
      @raw_data = raw_data
      @parsed_data = {}
    end

    def parse
      extract_data
      validate_data
      @parsed_data
    rescue StandardError => e
      Rails.logger.error("LiveOrderParser failed: #{e.message}")
      nil
    end

    private

    attr_reader :raw_data

    def extract_data
      @parsed_data = raw_data['Data'].slice(*REQUIRED_FIELDS)
    end

    def validate_data
      missing_fields = REQUIRED_FIELDS - @parsed_data.keys
      raise "Missing required fields: #{missing_fields.join(', ')}" unless missing_fields.empty?
    end
  end
end


# File: app/services/portfolio/holdings_service.rb


# File: app/services/portfolio/positions_service.rb


# File: app/services/portfolio_service.rb
# frozen_string_literal: true

class PortfolioService
  def self.fetch_holdings
    Dhanhq::API::Portfolio.holdings
  rescue StandardError => e
    Rails.logger.error("Error fetching holdings: #{e.message}")
    { error: e.message }
  end

  def self.fetch_positions
    Dhanhq::API::Portfolio.positions
  rescue StandardError => e
    Rails.logger.error("Error fetching positions: #{e.message}")
    { error: e.message }
  end
end


# File: app/services/repositories/instrument_repository.rb
# frozen_string_literal: true

class InstrumentRepository
  def self.find_by_symbol(symbol)
    Instrument.find_by(symbol_name: symbol)
  end

  def self.active_instruments
    Instrument.where(active: true)
  end
end


# File: app/services/repositories/order_repository.rb


# File: app/services/repositories/position_repository.rb


# File: app/services/statements_service.rb
# frozen_string_literal: true

class StatementsService
  def self.fetch_ledger(from_date, to_date)
    Dhanhq::API::Statements.ledger(from_date: from_date, to_date: to_date)
  rescue StandardError => e
    Rails.logger.error("Error fetching ledger: #{e.message}")
    { error: e.message }
  end

  def self.fetch_trade_history(from_date, to_date, page = 0)
    Dhanhq::API::Statements.trade_history(from_date: from_date, to_date: to_date, page: page)
  rescue StandardError => e
    Rails.logger.error("Error fetching trade history: #{e.message}")
    { error: e.message }
  end
end


# File: app/services/strategies/historical_data_fetcher.rb
# frozen_string_literal: true

module Strategies
  class HistoricalDataFetcher
    def initialize(security_id, exchange_segment, from_date, to_date)
      @security_id = security_id
      @exchange_segment = exchange_segment
      @from_date = from_date
      @to_date = to_date
    end

    def fetch
      DhanHQ::HistoricalData.new(
        security_id: @security_id,
        exchange_segment: @exchange_segment,
        from_date: @from_date,
        to_date: @to_date
      ).fetch_data
    end
  end
end


# File: app/services/strategies/index/intraday_strategy.rb
# frozen_string_literal: true

module Strategies
  module Index
    class IntradayStrategy < BaseStrategy
      def execute
        option_chain = fetch_option_chain
        strike_price = Option::ChainAnalyzer.new(option_chain).select_best_strike
        place_option_order(strike_price)
      end

      private

      def fetch_option_chain
        OptionChainService.fetch(alert.ticker, alert.exchange)
      end

      def place_option_order(strike_price)
        instrument = find_instrument_for_strike(strike_price)
        funds = fetch_funds
        quantity = calculate_option_quantity(instrument, funds)

        order_params = build_order_params(instrument, quantity, strike_price)
        response = OrderManager.place(order_params)

        Order.create!(response) if response.success?
      end

      def find_instrument_for_strike(strike_price)
        InstrumentRepository.find_by_strike(alert.ticker, strike_price)
      end

      def fetch_funds
        FundsService.fetch_funds[:availabelBalance]
      end

      def calculate_option_quantity(instrument, funds)
        lot_size = instrument.lot_size
        max_funds = funds * 0.3
        [(max_funds / instrument.last_price).floor, lot_size].max
      end

      def build_order_params(instrument, quantity, strike_price)
        {
          dhanClientId: ENV.fetch('DHAN_CLIENT_ID', nil),
          transactionType: alert.action.upcase,
          productType: 'INTRADAY',
          orderType: alert.order_type.upcase,
          securityId: instrument.security_id,
          quantity: quantity,
          price: strike_price
        }
      end
    end
  end
end


# File: app/services/strategies/stock/intraday_strategy.rb
# frozen_string_literal: true

module Strategies
  module Stock
    class IntradayStrategy < BaseStrategy
      def execute
        instrument = fetch_instrument
        mis_details = fetch_mis_details(instrument)
        funds = fetch_funds
        quantity = calculate_quantity(funds, mis_details, alert.current_price)

        order_params = build_order_params(instrument, quantity)
        response = OrderManager.place(order_params)

        Order.create!(response) if response.success?
      end

      private

      def fetch_instrument
        InstrumentRepository.find_by(symbol: alert.ticker)
      end

      def fetch_mis_details(instrument)
        instrument.mis_detail
      end

      def fetch_funds
        FundsService.fetch_funds[:availabelBalance]
      end

      def calculate_quantity(funds, mis_details, price)
        leverage = mis_details.mis_leverage || 1
        max_funds = funds * 0.3
        (max_funds / (price / leverage)).floor
      end

      def build_order_params(instrument, quantity)
        {
          dhanClientId: ENV.fetch('DHAN_CLIENT_ID', nil),
          transactionType: alert.action.upcase,
          productType: 'INTRADAY',
          orderType: alert.order_type.upcase,
          securityId: instrument.security_id,
          quantity: quantity,
          price: alert.limit_price
        }
      end
    end
  end
end


# File: app/services/strategies/supertrend_calculator.rb
# frozen_string_literal: true

module Stategies
  class SupertrendCalculator
    def initialize(data, atr_period, multiplier)
      @data = data
      @atr_period = atr_period
      @multiplier = multiplier
    end

    def calculate
      calculate_tr
      calculate_atr
      calculate_supertrend
      @data
    end

    private

    def calculate_tr
      @data.each_with_index do |row, index|
        next if index.zero?

        high_low = (row[:high] - row[:low]).abs
        high_close = (row[:high] - @data[index - 1][:close]).abs
        low_close = (row[:low] - @data[index - 1][:close]).abs
        @data[index][:tr] = [high_low, high_close, low_close].max
      end
    end

    def calculate_atr
      @data.each_with_index do |row, index|
        next if index < @atr_period

        tr_values = @data[(index - @atr_period + 1)..index].pluck(:tr)
        row[:atr] = tr_values.sum / @atr_period
      end
    end

    def calculate_supertrend
      @data.each_with_index do |row, index|
        next if index < @atr_period

        row[:upper_band] = ((row[:high] + row[:low]) / 2) + (@multiplier * row[:atr])
        row[:lower_band] = ((row[:high] + row[:low]) / 2) - (@multiplier * row[:atr])
        prev_supertrend = @data[index - 1][:supertrend] if index > @atr_period
        row[:supertrend] = if prev_supertrend.nil? || row[:close] > prev_supertrend
                             row[:lower_band]
                           else
                             row[:upper_band]
                           end
      end
    end
  end
end


# File: app/services/strategy_factory.rb
# frozen_string_literal: true

class StrategyFactory
  STRATEGY_MAP = {
    'Supertrend Strategy + Indicator' => Strategies::SupertrendStrategy,
    'VWAP Strategy' => Strategies::VWAPStrategy
  }.freeze

  def self.build(strategy_name)
    STRATEGY_MAP.fetch(strategy_name) { raise NotImplementedError, "Unknown strategy: #{strategy_name}" }.new
  end
end


# File: app/services/utils/error_handler.rb
# frozen_string_literal: true

module ErrorHandler
  MAX_RETRIES = 3

  def self.handle_error(context:, exception:, retries: 0, retry_logic: nil)
    ErrorLogger.log_error("#{context} failed", exception)

    if retries < MAX_RETRIES && retry_logic
      Rails.logger.info("#{context} retrying... Attempt #{retries + 1}")
      retry_logic.call
    else
      Rails.logger.error("#{context} max retries exceeded. Exception: #{exception.message}")
      { error: 'An unexpected error occurred. Please try again later.' }
    end
  end
end


# File: app/services/utils/error_logger.rb
# frozen_string_literal: true

module ErrorLogger
  def self.log_error(message, exception = nil)
    Rails.logger.error("#{message}: #{exception&.message}")
    # Integrate with external monitoring tools like Sentry or Rollbar here
  end
end


# File: app/services/utils/instrument_utils.rb
# frozen_string_literal: true

module InstrumentUtils
  def self.find_instrument_by_symbol(symbol, segment, exchange)
    Instrument.find_by!(
      underlying_symbol: symbol,
      segment: segment,
      exchange: exchange
    )
  rescue ActiveRecord::RecordNotFound
    raise "Instrument not found for symbol: #{symbol}, segment: #{segment}, exchange: #{exchange}"
  end

  def self.find_instrument_with_options(strike_price, expiry_date, option_type)
    Instrument.joins(:derivative).find_by!(
      'derivatives.strike_price = ? AND derivatives.option_type = ? AND derivatives.expiry_date = ?',
      strike_price, option_type, expiry_date
    )
  rescue ActiveRecord::RecordNotFound
    raise "Option not found for strike: #{strike_price}, expiry: #{expiry_date}, type: #{option_type}"
  end
end


# File: app/services/utils/market_feed_parser.rb
# frozen_string_literal: true

class MarketFeedParser
  def self.parse(io, fields)
    fields.index_with do |field|
      read_field(io, field)
    end
  rescue StandardError => e
    raise "Market feed parsing failed: #{e.message}"
  end

  def self.read_field(io, field)
    case field
    when :last_traded_price then io.read(4).unpack1('F')
    when :volume then io.read(4).unpack1('N')
      # Add cases for other field types
    end
  end
end


# File: app/services/utils/response_helper.rb
# frozen_string_literal: true

module ResponseHelper
  def self.error_response(message, status = :unprocessable_entity)
    { error: { message: message, status: Rack::Utils.status_code(status) } }
  end

  def self.success_response(data, status = :ok)
    { data: data, status: Rack::Utils.status_code(status) }
  end
end


# File: app/services/validators/alert_validator.rb
# frozen_string_literal: true

class AlertValidator
  include ActiveModel::Model

  attr_accessor :ticker, :instrument_type, :action, :order_type, :current_position,
                :previous_position, :current_price, :high, :low, :volume, :time,
                :stop_loss, :take_profit, :trailing_stop_loss, :strategy_name, :strategy_id

  validates :ticker, :instrument_type, :action, :order_type, :strategy_name, :strategy_id, presence: true
  validates :instrument_type, inclusion: { in: %w[stock index] }
  validates :action, inclusion: { in: %w[buy sell] }
  validates :order_type, inclusion: { in: %w[market limit stop] }
  validates :current_price, :stop_loss, :take_profit, numericality: { greater_than: 0 }
  validates :volume, numericality: { only_integer: true, greater_than_or_equal_to: 0 }
  validates :time, presence: true

  def initialize(params = {})
    super(params.permit(:ticker, :instrument_type, :action, :order_type, :current_position,
                        :previous_position, :current_price, :high, :low, :volume, :time,
                        :stop_loss, :take_profit, :trailing_stop_loss, :strategy_name, :strategy_id))
  end
end


# File: app/services/websocket_handlers/base_websocket.rb
# frozen_string_literal: true

require 'faye/websocket'

class BaseWebSocket
  def initialize(url, auth_message)
    @url = url
    @auth_message = auth_message
    @websocket = nil
  end

  def connect
    EM.run do
      @websocket = Faye::WebSocket::Client.new(@url)
      setup_callbacks
    end
  end

  def send_message(message)
    @websocket&.send(message.to_json)
  end

  private

  def setup_callbacks
    @websocket.on(:open) { handle_open }
    @websocket.on(:message) { |event| handle_message(event.data) }
    @websocket.on(:close) { |event| handle_close(event) }
    @websocket.on(:error) { |event| handle_error(event) }
  end

  def handle_open
    send_message(@auth_message)
    Rails.logger.info('WebSocket connection opened.')
  end

  def handle_message(data)
    Rails.logger.info("Received message: #{data}")
  end

  def handle_close(event)
    Rails.logger.warn("WebSocket connection closed: #{event.code} - #{event.reason}")
    EM.stop
  end

  def handle_error(event)
    ErrorLogger.log_error('WebSocket error', event)
  end
end


# File: app/services/websocket_handlers/live_market_feed.rb
# frozen_string_literal: true

require 'faye/websocket'
require 'eventmachine'
require 'json'

class LiveMarketFeed
  MAX_INSTRUMENTS_PER_BATCH = 100

  def initialize
    @url = build_url
    @subscribed_instruments = []
  end

  def connect
    EM.run do
      @ws = Faye::WebSocket::Client.new(@url)

      @ws.on(:open) do |_event|
        Rails.logger.info '[LiveMarketFeed] WebSocket connection established.'
      end

      @ws.on(:message) do |event|
        handle_message(event.data)
      end

      @ws.on(:close) do |event|
        Rails.logger.warn "[LiveMarketFeed] WebSocket connection closed: Code=#{event.code}, Reason=#{event.reason}"
        EM.stop
      end

      @ws.on(:error) do |event|
        Rails.logger.error "[LiveMarketFeed] WebSocket encountered an error: #{event.message}"
      end
    end
  end

  def subscribe_to_instruments(instruments)
    instruments.each_slice(MAX_INSTRUMENTS_PER_BATCH) do |batch|
      subscription_message = {
        RequestCode: 15,
        InstrumentCount: batch.size,
        InstrumentList: batch.map do |inst|
          { ExchangeSegment: inst[:exchange_segment], SecurityId: inst[:security_id] }
        end
      }

      send_message(subscription_message)
    end

    @subscribed_instruments.concat(instruments)
    Rails.logger.info "[LiveMarketFeed] Subscribed to #{instruments.size} instruments."
  end

  def unsubscribe_all
    send_message({ RequestCode: 16 })
    @subscribed_instruments.clear
    Rails.logger.info '[LiveMarketFeed] Unsubscribed from all instruments.'
  end

  private

  def build_url
    token = ENV.fetch('DHAN_ACCESS_TOKEN')
    client_id = ENV.fetch('DHAN_CLIENT_ID')
    "wss://api-feed.dhan.co?version=2&token=#{token}&clientId=#{client_id}&authType=2"
  end

  def send_message(message)
    if @ws
      @ws.send(message.to_json)
      Rails.logger.info "[LiveMarketFeed] Sent message: #{message}"
    else
      Rails.logger.error '[LiveMarketFeed] WebSocket connection not established. Cannot send message.'
    end
  end

  def handle_message(data)
    # Market feed messages are in binary and need to be parsed
    parsed_data = MarketFeed::PacketParser.parse(data)
    MarketFeed::DataProcessor.new(parsed_data).process
  rescue JSON::ParserError => e
    Rails.logger.error "[LiveMarketFeed] Failed to parse message: #{e.message}. Raw data: #{data}"
  rescue StandardError => e
    Rails.logger.error "[LiveMarketFeed] Error processing message: #{e.message}"
  end
end


# File: app/services/websocket_handlers/live_order_update.rb
# frozen_string_literal: true

class LiveOrderWebSocket < BaseWebSocket
  def handle_message(data)
    order_data = JSON.parse(data)
    OrderProcessor.process(order_data)
  rescue JSON::ParserError => e
    ErrorLogger.log_error('Failed to parse WebSocket message', e)
  end
end


# File: app/services/websocket_handlers/websocket_manager.rb
# frozen_string_literal: true

class WebSocketManager
  def initialize(url, auth_message)
    @url = url
    @auth_message = auth_message
    @websocket = nil
  end

  def connect
    EM.run do
      @websocket = Faye::WebSocket::Client.new(@url)

      @websocket.on(:open) { |event| handle_open(event) }
      @websocket.on(:message) { |event| handle_message(event) }
      @websocket.on(:close) { |event| handle_close(event) }
      @websocket.on(:error) { |event| handle_error(event) }
    end
  end

  def send_message(message)
    @websocket&.send(message.to_json)
  end

  private

  def handle_open(_event)
    Rails.logger.info('WebSocket connection opened.')
    send_message(@auth_message)
  end

  def handle_message(event)
    # Process incoming WebSocket messages
  end

  def handle_close(event)
    Rails.logger.warn("WebSocket connection closed: #{event.code} - #{event.reason}")
    EM.stop
  end

  def handle_error(event)
    Rails.logger.error("WebSocket error: #{event.message}")
  end
end


# File: app/views/layouts/mailer.html.erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>


# File: app/views/layouts/mailer.text.erb
<%= yield %>


# File: lib/tasks/csv_import.rake
# frozen_string_literal: true

namespace :csv do
  desc 'Import instruments from CSV'
  task import: :environment do
    puts 'Starting CSV import process...'

    # Dynamically download and import the CSV
    CsvImporter.import

    puts 'CSV import completed successfully!'
  rescue StandardError => e
    puts "An error occurred during the import: #{e.message}"
    puts e.backtrace.join("\n")
  end
end


# File: lib/tasks/import_mis_data.rake
# frozen_string_literal: true

namespace :data do
  desc 'Import MIS Details from CSV'
  task import_mis: :environment do
    require 'csv'

    # Define the path to the CSV file
    file_path = Rails.root.join('mis_data.csv')

    # Check if the file exists
    unless File.exist?(file_path)
      puts "File not found at #{file_path}. Please make sure the file is present in the root folder."
      exit
    end

    begin
      # Start processing the CSV file
      puts "Starting MIS data import from #{file_path}..."

      CSV.foreach(file_path, headers: true) do |row|
        # Skip rows with missing critical data
        if row['Symbol / Scrip Name'].blank?

          puts "Skipping row due to missing critical data: #{row.to_h}"
          Rails.logger.warn "Skipping row due to missing critical data: #{row.to_h}"
          next
        end

        # Fetch the associated instruments
        instruments = Instrument.where(underlying_symbol: row['Symbol / Scrip Name'], isin: row['ISIN'])

        if instruments.empty?
          Rails.logger.warn "No matching instruments found for Symbol: #{row['Symbol / Scrip Name']}, Exchange: #{row['Exchange ID']}, Segment: #{row['Segment Code']}"
          next
        end

        instruments.each do |instrument|
          # Update or create MIS details for the instrument
          mis_detail = MisDetail.find_or_initialize_by(instrument: instrument)
          mis_detail.assign_attributes(
            isin: row['ISIN'],
            mis_leverage: row['MIS(Intraday)']&.delete('x')&.to_i,
            bo_leverage: row['BO(Bracket)']&.delete('x')&.to_i,
            co_leverage: row['CO(Cover)']&.delete('x')&.to_i
          )

          if mis_detail.save
            puts "Updated MIS details for Instrument: #{instrument.symbol_name} (#{instrument.security_id})"
          else
            Rails.logger.error "Failed to save MIS details for Instrument: #{instrument.symbol_name}. Errors: #{mis_detail.errors.full_messages.join(', ')}"
          end
        end
      end

      puts 'MIS data import completed successfully!'
    rescue StandardError => e
      Rails.logger.error "An error occurred during MIS data import: #{e.message}"
      Rails.logger.error e.backtrace.join("\n")
      puts 'MIS data import failed. Check the logs for details.'
    end
  end
end


# File: lib/tasks/schedule_jobs.rake
# frozen_string_literal: true

namespace :jobs do
  desc 'Schedule periodic jobs for OrderManager and PositionManager'
  task schedule: :environment do
    OrderManagerJob.set(queue: 'order_manager', wait: 5.minutes).perform_later
    PositionManagerJob.set(queue: 'position_manager', wait: 10.minutes).perform_later

    puts 'Jobs have been scheduled.'
  end
end


# File: lib/tasks/strategy_example_updater.rake
# frozen_string_literal: true

namespace :strategy do
  desc 'Update strategy examples with current option chain data'
  task update_examples: :environment do
    option_chain = {} # Fetch or mock the option chain data
    params = { index_symbol: 'Nifty' }

    Option::StrategyExampleUpdater.update_examples(option_chain, params)
    puts 'Strategy examples updated successfully.'
  end
end


# File: config/initializers/cors.rb
# frozen_string_literal: true

# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin Ajax requests.

# Read more: https://github.com/cyu/rack-cors

Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins 'http://localhost:3000', /.*\.ngrok-free\.app/ # Allow localhost and ngrok subdomains

    resource '*',
             headers: :any,
             methods: %i[get post put patch delete options head],
             expose: ['Authorization'] # Expose any custom headers your API might send
  end
end


# File: config/initializers/delayed_job_config.rb
# frozen_string_literal: true

Delayed::Worker.destroy_failed_jobs = false
Delayed::Worker.sleep_delay = 60
Delayed::Worker.max_attempts = 3
Delayed::Worker.max_run_time = 5.minutes
Delayed::Worker.read_ahead = 10
Delayed::Worker.default_queue_name = 'default'
Delayed::Worker.delay_jobs = !Rails.env.test?
Delayed::Worker.logger = Logger.new(Rails.root.join('log/delayed_job.log').to_s)


# File: config/initializers/dhanhq_mappings.rb
# frozen_string_literal: true

module DhanhqMappings
  EXCHANGES = {
    'NSE' => 'National Stock Exchange',
    'BSE' => 'Bombay Stock Exchange',
    'MCX' => 'Multi Commodity Exchange'
  }.freeze

  # SEGMENTS = {
  #   "IDX_I" => "Index",
  #   "NSE_EQ" => "Equity Cash",
  #   "NSE_FNO" => "Futures & Options",
  #   "NSE_CURRENCY" => "Currency",
  #   "BSE_EQ" => "Equity Cash",
  #   "MCX_COMM" => "Commodity"
  # }.freeze

  SEGMENTS = {
    I: 'Index',
    E: 'Equity',
    D: 'Derivatives',
    C: 'Currency',
    M: 'Commodity'
  }.freeze

  PRODUCT_TYPES = {
    'CNC' => 'Cash & Carry',
    'INTRADAY' => 'Intraday',
    'MARGIN' => 'Carry Forward',
    'CO' => 'Cover Order',
    'BO' => 'Bracket Order'
  }.freeze

  ORDER_STATUSES = {
    'TRANSIT' => 'Did not reach the exchange server',
    'PENDING' => 'Awaiting execution',
    'REJECTED' => 'Rejected by broker/exchange',
    'CANCELLED' => 'Cancelled by user',
    'TRADED' => 'Executed successfully',
    'EXPIRED' => 'Validity expired'
  }.freeze

  INSTRUMENT_TYPES = {
    'INDEX' => 'Index',
    'FUTIDX' => 'Futures of Index',
    'OPTIDX' => 'Options of Index',
    'EQUITY' => 'Equity',
    'FUTSTK' => 'Futures of Stock',
    'OPTSTK' => 'Options of Stock'
  }.freeze

  EXPIRY_FLAGS = {
    'M' => 'Monthly Expiry',
    'W' => 'Weekly Expiry'
  }.freeze
end


# File: config/initializers/dhanhq.rb
# frozen_string_literal: true

require 'dhanhq'

Dhanhq.configure do |config|
  config.client_id = ENV.fetch('DHAN_CLIENT_ID', nil)
  config.access_token = ENV.fetch('DHAN_ACCESS_TOKEN', nil)
end


# File: config/initializers/filter_parameter_logging.rb
# frozen_string_literal: true

# Be sure to restart your server when you modify this file.

# Configure parameters to be partially matched (e.g. passw matches password) and filtered from the log file.
# Use this to limit dissemination of sensitive information.
# See the ActiveSupport::ParameterFilter documentation for supported notations and behaviors.
Rails.application.config.filter_parameters += %i[
  passw email secret token _key crypt salt certificate otp ssn cvv cvc
]


# File: config/initializers/inflections.rb
# frozen_string_literal: true

# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end


# File: config/initializers/websockets.rb
# frozen_string_literal: true

Thread.new do
  # Start Live Market Feed WebSocket
  begin
    market_feed = LiveMarketFeed.new
    market_feed.connect
  rescue StandardError => e
    Rails.logger.error "[WebSocket] Error starting LiveMarketFeed: #{e.message}"
  end

  # Start Live Order Update WebSocket
  begin
    order_update = LiveOrderUpdate.new
    order_update.connect
  rescue StandardError => e
    Rails.logger.error "[WebSocket] Error starting LiveOrderUpdate: #{e.message}"
  end
end


