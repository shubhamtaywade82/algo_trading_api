// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © AlgoAlpha

//  ──────────────────────────────────────────────────────────────
//  ML Adaptive SuperTrend  –  refactored & annotated
//  Original idea by AlgoAlpha – modified for clarity
//  ──────────────────────────────────────────────────────────────
//@version=6
strategy("ML Adaptive SuperTrend [nemesis]", "ML-ST n", overlay = true, default_qty_type = strategy.fixed, default_qty_value = 1, commission_type = strategy.commission.percent, commission_value = 0.03, max_labels_count = 100, calc_on_every_tick = true)

strategyType = input.string("intraday",  "Strategy Type", options=["intraday","swing","long_term"])
orderType    = input.string("market",    "Order Type",    options=["market","limit"])
strategyTitle = "ML Adaptive Supertrend"

atrLen = input.int(10, "ATR Length", group = "SuperTrend Settings")
fact = input.float(1, "SuperTrend Factor", group = "SuperTrend Settings")
training_data_period = input.int(100, "Training Data Length", group = "K-Means Settings")
highvol = input.float(0.75, "Initial High volatility Percentile Guess", maxval = 1, group = "K-Means Settings", tooltip = "The initial guess of where the potential 'high volatility' area is, a value of 0.75 will take the 75th percentile of the range of ATR values over the training data period")
midvol = input.float(0.5, "Initial Medium volatility Percentile Guess", maxval = 1, group = "K-Means Settings", tooltip = "The initial guess of where the potential 'medium volatility' area is, a value of 0.5 will take the 50th percentile of the range of ATR values over the training data period")
lowvol = input.float(0.25, "Initial Low volatility Percentile Guess", maxval = 1, group = "K-Means Settings", tooltip = "The initial guess of where the potential 'low volatility' area is, a value of 0.25 will take the 25th percentile of the range of ATR values over the training data period")

useAtrExit = input.bool(true, "Enable ATR-based Exits?", group="ATR Exits")
slATRmult = input.float(1.3, "SL ATR multiplier", group="ATR Exits")
tpATRmult = input.float(2.8, "TP ATR multiplier", group="ATR Exits")
t1 = input.int(70, "Transparency 1", maxval = 100, minval = 0, group = "Appearance")
t2 = input.int(95, "Transparency 2", maxval = 100, minval = 0, group = "Appearance")
green = input.color(color.blue, "Bullish Color", group = "Appearance")
red = input.color(#ff1100, "Bearish Color", group = "Appearance")

pine_supertrend(factor, atr) =>
    src = hl2
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int _direction = na
    float superTrend = na
    prevSuperTrend = superTrend[1]
    if na(atr[1])
        _direction := 1
    else if prevSuperTrend == prevUpperBand
        _direction := close > upperBand ? -1 : 1
    else
        _direction := close < lowerBand ? 1 : -1
    superTrend := _direction == -1 ? lowerBand : upperBand
    [superTrend, _direction]

volatility = ta.atr(atrLen)

upper = ta.highest(volatility, training_data_period)
lower = ta.lowest(volatility, training_data_period)

high_volatility = lower + (upper-lower) * highvol
medium_volatility = lower + (upper-lower) * midvol
low_volatility = lower + (upper-lower) * lowvol

iterations = 0

size_a = 0
size_b = 0
size_c = 0

hv = array.new_float()
mv = array.new_float()
lv = array.new_float()
amean = array.new_float(1,high_volatility)
bmean = array.new_float(1,medium_volatility)
cmean = array.new_float(1,low_volatility)

if nz(volatility) > 0 and bar_index >= training_data_period-1
    while ((amean.size() == 1 ? true : (amean.first() != amean.get(1))) or (bmean.size() == 1 ? true : (bmean.first() != bmean.get(1))) or (cmean.size() == 1 ? true : (cmean.first() != cmean.get(1))))
        hv.clear()
        mv.clear()
        lv.clear()
        for i = training_data_period-1 to 0
            _1 = math.abs(volatility[i] - amean.first())
            _2 = math.abs(volatility[i] - bmean.first())
            _3 = math.abs(volatility[i] - cmean.first())
            if _1 < _2 and _1 < _3
                hv.unshift(volatility[i])

            if _2 < _1 and _2 < _3
                mv.unshift(volatility[i])

            if _3 < _1 and _3 < _2
                lv.unshift(volatility[i])

        amean.unshift(hv.avg())
        bmean.unshift(mv.avg())
        cmean.unshift(lv.avg())
        size_a := hv.size()
        size_b := mv.size()
        size_c := lv.size()
        iterations := iterations + 1

hv_new = amean.first()
mv_new = bmean.first()
lv_new = cmean.first()
vdist_a = math.abs(volatility - hv_new)
vdist_b = math.abs(volatility - mv_new)
vdist_c = math.abs(volatility - lv_new)

distances = array.new_float()
centroids = array.new_float()

distances.push(vdist_a)
distances.push(vdist_b)
distances.push(vdist_c)

centroids.push(hv_new)
centroids.push(mv_new)
centroids.push(lv_new)

cluster = distances.indexof(distances.min()) // 0 for high, 1 for medium, 2 for low
assigned_centroid = cluster == -1 ? na : centroids.get(cluster)

[ST, dir] = pine_supertrend(fact, assigned_centroid)

upTrend = plot(close > ST ? ST : na, color = color.new(green, t1), style = plot.style_linebr) //, force_overlay = true
downTrend = plot(close < ST ? ST : na, color = color.new(red, t1), style = plot.style_linebr, force_overlay = false) //, force_overlay = true
bodyMiddle = plot(barstate.isfirst ? na : (open + close) / 2, "Body Middle",display = display.none)

fill(bodyMiddle, upTrend, (open + close) / 2, ST, color.new(green, t2), color.new(green, t1))
fill(bodyMiddle, downTrend, ST, (open + close) / 2, color.new(red, t1), color.new(red, t2))

// ─────────── Strategy ENTRY signals ───────────
bullShift = ta.crossunder(dir, 0)     //   red → green
bearShift = ta.crossover (dir, 0)     //   green → red

plotshape(bullShift ? ST : na, "Bullish Trend", shape.labelup, location.absolute, green, text = "Bullish", textcolor = chart.fg_color, size = size.small)
plotshape(bearShift ? ST : na, "Bearish Trend", shape.labeldown, location.absolute, red, text = "Bearish", textcolor = chart.fg_color, size = size.small)

label.new(bar_index, dir > 0 ? ST + ta.atr(7) : ST - ta.atr(7), text = str.tostring(4 - (cluster + 1)), style = label.style_none, textcolor = color.from_gradient(cluster + 1, 1, 3, color.new(dir > 0 ? red : green, 30), color.new(dir > 0 ? red : green, 90)))


var float entryATR = na      // frozen ATR at entry‑1 bar
var float stopLvl  = na      // current stop level
var float tpLvl    = na      // current take‑profit level

jsonAlert(_signal, _action, _currPos, _prevPos) =>
    '{ "alert": {'  + '"ticker":"' + syminfo.ticker + '",' + '"instrument_type":"' + syminfo.type + '",' +'"exchange":"' + syminfo.prefix + '",' +'"time":"' + str.format_time(time, "yyyy-MM-dd\'T\'HH:mm:ssZ", syminfo.timezone) + '",' + '"strategy_type":"' +  strategyType + '",' + '"order_type":"'        + orderType  + '",' + '"action":"' + _action + '",' + '"current_position":"'  + _currPos + '",' + '"previous_position":"' + _prevPos  + '",' + '"current_price":' + str.tostring(close, "#.##") + ','  + '"chart_interval":"' + timeframe.period + '",' + '"strategy_name":"' + strategyTitle + '",' + '"strategy_id":"' + syminfo.ticker + "_" + strategyType + '",' + '"signal_type":"' + _signal + '"'+'} }'

// ───── calculate once per bar ─────
atrNow = ta.atr(atrLen)

// capture ATR **once** – the bar right after the position is opened
if strategy.opentrades == 1 and strategy.opentrades.entry_bar_index(0) == bar_index-1
    entryATR := atrNow
    float riskPts = slATRmult * entryATR
    stopLvl  := strategy.position_size > 0 ? strategy.position_avg_price - riskPts : strategy.position_avg_price + riskPts
    tpLvl    := tpATRmult == 0 ? na : strategy.position_size > 0 ? strategy.position_avg_price + tpATRmult*riskPts : strategy.position_avg_price - tpATRmult*riskPts

// trail the stop *only* in the profitable direction
if strategy.position_size > 0
    stopLvl := math.max(stopLvl, low)
if strategy.position_size < 0
    stopLvl := math.min(stopLvl, high)

// ─────────── ENTRIES ───────────
if bullShift
    strategy.entry("Long" , strategy.long )
    alert(jsonAlert("long_entry", "buy", "long", "flat"), alert.freq_once_per_bar)

if bearShift
    strategy.entry("Short", strategy.short)
    alert(jsonAlert("short_entry", "sell", "short", "flat"), alert.freq_once_per_bar)

// ATR-based exits
// track prcious positions
var float prevPos = na
prevPos := nz(prevPos[0], 0)
longSL = strategy.position_avg_price - slATRmult * volatility
longTP = strategy.position_avg_price + tpATRmult * volatility
shortSL = strategy.position_avg_price + slATRmult * volatility
shortTP = strategy.position_avg_price - tpATRmult * volatility

// ATR-based exits
if useAtrExit
    if strategy.position_size > 0
        strategy.exit("LongExit", from_entry="Long", stop=longSL, limit=longTP)

    if strategy.position_size < 0
        strategy.exit("ShortExit", from_entry="Short", stop=shortSL, limit=shortTP)

if useAtrExit
    // Detect exit (only once when position closes)
    exitedLong = prevPos > 0 and strategy.position_size == 0
    exitedShort = prevPos < 0 and strategy.position_size == 0
    if exitedLong
        alert(jsonAlert("long_exit", "sell", "flat", "long"), alert.freq_once_per_bar)
    if exitedShort
        alert(jsonAlert("short_exit", "buy", "flat", "short"), alert.freq_once_per_bar)
// else
//     strategy.close_all(comment="Manual Close on Flip")
//     //alert(jsonAlert(strategy.position_size[1] > 0 ? "long_exit" : "short_exit", strategy.position_size[1] > 0 ? "sell" : "buy", "flat", strategy.position_size[1] > 0 ? "long" : "short"), alert.freq_once_per_bar)
//     exited = prevPos != 0 and strategy.position_size == 0
//     if exited
//         alert(jsonAlert(prevPos > 0 ? "long_exit" : "short_exit", prevPos > 0 ? "sell" : "buy", "flat", prevPos > 0 ? "long" : "short"), alert.freq_once_per_bar)

// Update previous position size
prevPos := strategy.position_size

// ATR SL/TP plotting
plot(useAtrExit and strategy.position_size != 0 ? strategy.position_size > 0 ? longSL : shortSL : na, title="ATR Stop", color=color.new(color.white, 50), style = plot.style_linebr)
plot(useAtrExit and strategy.position_size != 0 ? strategy.position_size > 0 ? longTP : shortTP : na, title="ATR TP", color=color.new(color.blue, 50), style = plot.style_linebr)

// ---------------------------------- STATS TABLE - BACK TESTING RESULTS -------------------------
showStats = input.bool(true, title="Show Stats Table?")
var table statsTable = table.new(position.top_right, 2, 7, border_width=1)

if showStats and bar_index % 5 == 0
    totalTrades = strategy.closedtrades
    wins = strategy.wintrades
    losses = strategy.losstrades
    winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0.0
    netProfit = strategy.netprofit
    avgProfit = totalTrades > 0 ? netProfit / totalTrades : 0.0
    colorNet = netProfit > 0 ? color.green : color.red
    colorWin = winRate > 50 ? color.green : color.red
    colorAvg = avgProfit > 0 ? color.green : color.red
    perfRating = winRate > 60 and netProfit > 0 ? "★ Excellent" : winRate > 50 ? "✓ Good" : "⚠️ Weak"
    netProfitPct = (netProfit / strategy.initial_capital) * 100

    table.cell(statsTable, 0, 0, "Total Trades", text_color=color.white)
    table.cell(statsTable, 1, 0, str.tostring(totalTrades), text_color=color.white)
    table.cell(statsTable, 0, 1, "Wins", text_color=color.white)
    table.cell(statsTable, 1, 1, str.tostring(wins), text_color=color.green)
    table.cell(statsTable, 0, 2, "Losses", text_color=color.white)
    table.cell(statsTable, 1, 2, str.tostring(losses), text_color=color.red)
    table.cell(statsTable, 0, 3, "Win Rate", text_color=color.white)
    table.cell(statsTable, 1, 3, str.tostring(winRate, "#.##") + "%", text_color=colorWin)
    table.cell(statsTable, 0, 4, "Net Profit", text_color=color.white)
    table.cell(statsTable, 1, 4, str.tostring(netProfit, "#.##"), text_color=colorNet)
    table.cell(statsTable, 0, 5, "Rating", text_color=color.white)
    table.cell(statsTable, 1, 5, perfRating, text_color=color.yellow)
    table.cell(statsTable, 0, 6, "Profit %", text_color=color.white)
    table.cell(statsTable, 1, 6, str.tostring(netProfitPct, "#.##") + "%", text_color=colorNet)